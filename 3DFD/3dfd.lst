%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          S u m m a r y   R e p o r t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Compilation
-----------
File     : /cray/css/u19/jan/src/3DFD/3dfd.c
Compiled : 2015-09-11  09:03:10
Compiler : Version 8.4.0.223
Ftnlx    : Version 8412 (libcif 84005)
Target   : x86-64
Command  : driver.cc -h cpu=haswell -h dynamic -D __CRAYCS -D __CRAY_HASWELL
           -D __CRAYXT_COMPUTE_LINUX_TARGET -O 3 -h fp3 -h noomp -h list=a -I .
           -c 3dfd.c -W l,--rpath=/opt/cray/cce/8.4.0.223/craylibs/x86-64
           -ibase-compiler /opt/cray/cce/8.4.0.223/CC/x86-64/compiler_include_ba
           se -isystem /opt/cray/cce/8.4.0.223/craylibs/x86-64/include
           -isystem /usr/local/cuda/include
           -I /opt/gcc/4.8.1/snos/lib/gcc/x86_64-suse-linux/4.8.1/include
           -I /opt/gcc/4.8.1/snos/lib/gcc/x86_64-suse-linux/4.8.1/include-fixed
           -I /opt/cray/mvapich2_slurm/2.0.1.4/CRAY/8.4/include
           -I /opt/cray/libsci/13.2.0.1/CRAY/8.3/x86_64/include
           -I /global/opt/nvidia/cudatoolkit/7.0.28/include
           -I /opt/cray/cce/8.4.0.223/craylibs/x86-64/include

clx report
------------
Source   : /cray/css/u19/jan/src/3DFD/3dfd.c
Date     : 09/11/2015  09:03:14


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          O p t i o n s   R e p o r t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Options :  -h cache2,fp3,scalar3,thread2,vector3,mpi0,ipa3,noaggress         
           -h autoprefetch,noautothread,fusion2,nomsgs,nonegmsgs         
           -h nooverindex,pattern,unroll2,nozeroinc         
           -h noadd_paren,noupc,dwarf,nofp_trap,nofunc_trace         
           -h noomp_analyze,noomp_trace,nopat_trace         
           -h noomp,noomp_acc,noacc         
           -h c99,noexceptions,nostrict,noinfinitevl         
           -h notolerant,gnu         
           -h flex_mp=default         
           -h cpu=x86-64,haswell
           -h network=gemini         
           -K trap=none 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          S o u r c e   L i s t i n g
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


     %%%    L o o p m a r k   L e g e n d    %%%

     Primary Loop Type        Modifiers
     ------- ---- ----        ---------
     A - Pattern matched      a - atomic memory operation
                              b - blocked
     C - Collapsed            c - conditional and/or computed
     D - Deleted               
     E - Cloned                
     F - Flat - No calls      f - fused
     G - Accelerated          g - partitioned
     I - Inlined              i - interchanged
     M - Multithreaded        m - partitioned
                              n - non-blocking remote transfer
                              p - partial
                              r - unrolled
                              s - shortloop
     V - Vectorized           w - unwound

     + - More messages listed at end of listing
     ------------------------------------------


    1.               #include<mpi.h>
    2.               #include<stdlib.h>
    3.               #include<stdio.h>
    4.               #include<math.h>
    5.               #include<time.h>
    6.               #include<assert.h>
    7.               #include<sys/time.h>
    8.               #include"par.h"
    9.               #include"fdelmodc.h"
   10.               
   11.               #define MAX(x,y) ((x) > (y) ? (x) : (y))
   12.               #define MIN(x,y) ((x) < (y) ? (x) : (y))
   13.               #define NINT(x) ((int)((x)>0.0?(x)+0.5:(x)-0.5))
   14.               
   15.               
   16.               #define STRIPE_COUNT "4" /* must be an ascii string */
   17.               #define STRIPE_SIZE "1048576" /* 1 MB must be an ascii string */
   18.               //#define STRIPE_SIZE "268435456" /* 256 MB must be an ascii string */
   19.               #define C1 (9.0/8.0)
   20.               #define C2 (1.0/24.0)
   21.               #define Dx(f,ix,iy,iz,nz) C1*(f[iy+ix*nz+iz] - f[iy+(ix-1)*nz+iz]) - C2*(f[iy+(ix+1)*nz+iz] - f[iy+(ix-2)*nz+iz])
   22.               #define Dy(f,ix,iy,iz,nxz) C1*(f[iy*nxz+ix+iz] - f[(iy-1)*nxz+ix+iz]) - C2*(f[(iy+1)*nxz+ix+iz] - f[(iy-2)*nxz+ix+iz])
   23.               #define Dz(f,ix,iy,iz) C1*(f[iy+ix+iz] - f[iy+ix+iz-1]) - C2*(f[iy+ix+iz+1] - f[iy+ix+iz-2])
   24.               
   25.               #define Dv(vx,vz,ix,iy,iz,nz,nxz) C1*((vx[iy*nxz+(ix+1)*nz+iz] - vx[iy*nxz+ix*nz+iz]) + \
   26.               				      (vy[(iy+1)*nxz+ix*nz+iz] - vy[iy*nxz+ix*nz+iz]) + \
   27.               				      (vz[iy*nxz+ix*nz+iz+1]   - vz[iy*nxz+ix*nz+iz])) - \
   28.               				  C2*((vx[iy*nxz+(ix+2)*nz+iz] - vx[iy*nxz+(ix-1)*nz+iz]) + \
   29.               				      (vy[(iy+2)*nxz+ix*nz+iz] - vy[(iy-1)*nxz+ix*nz+iz]) + \
   30.               				      (vz[iy*nxz+ix*nz+iz+2]   - vz[iy*nxz+ix*nz+iz-1]))
   31.               
   32.               void vinit();
   33.               int updateVelocitiesHalo(float *vx, float *vy, float *vz, float *p, float *ro, int halo, int npx, int npy, int npz);
   34.               int updateVelocities(float *vx, float *vy, float *vz, float *p, float *ro, int halo, int npx, int npy, int npz);
   35.               int updatePressureHalo(float *vx, float *vy, float *vz, float *p, float *l2m, int halo, int npx, int npy, int npz);
   36.               int updatePressure(float *vx, float *vy, float *vz, float *p, float *l2m, int halo, int npx, int npy, int npz);
   37.               int exchangeHalo(float *leftRecv, float *leftSend, float *rightRecv, float *rightSend, int size, int leftrank, int rightrank, MPI_Request *reqRecv, MPI_Request *reqSend, int tag);
   38.               int newHaloVxVz(float *vx, float *vz, int npx, int npy, int npz, int halo, float *leftRecv, float *rightRecv, float *frontRecv, float *backRecv, float *topRecv, float *bottomRecv);
   39.               int newHaloP(float *p, int npx, int npy, int npz, int halo, float *leftRecv, float *rightRecv, float *frontRecv, float *backRecv, float *topRecv, float *bottomRecv);
   40.               int copyHaloVxVz(float *vx, float *vz, int npx, int npy, int npz, int halo, float *leftSend, float *rightSend, float *frontSend, float *backSend, float *topSend, float *bottomSend);
   41.               int copyHaloP(float *p, int npx, int npy, int npz, int halo, float *leftSend, float *rightSend, float *frontSend, float *backSend, float *topSend, float *bottomSend);
   42.               int waitForHalo(MPI_Request *reqRecv, MPI_Request *reqSend);
   43.               float gauss2time(float t, float f, float t0);
   44.               double wallclock_time(void);
   45.               int getParameters(modPar *mod, recPar *rec, snaPar *sna, wavPar *wav, srcPar *src, shotPar *shot, bndPar *bnd, int verbose);
   46.               
   47.               /* Self documentation */
   48.               char *sdoc[] = {
   49.               " ",
   50.               " fdelmodc - elastic acoustic finite difference wavefield modeling ",
   51.               " ",
   52.               " IO PARAMETERS:",
   53.               "   file_cp= .......... P (cp) velocity file",
   54.               "   file_cs= .......... S (cs) velocity file",
   55.               "   file_den= ......... density (ro) file",
   56.               "   file_src= ......... file with source signature",
   57.               "   file_rcv=recv.su .. base name for receiver files",
   58.               "   file_snap=snap.su . base name for snapshot files",
   59.               "   file_beam=beam.su . base name for beam fields ",
   60.               "   rcv_txt=........... text file with receiver coordinates. Col 1: x, Col. 2: z",
   61.               "   dx= ............... read from model file: if dx==0 then dx= can be used to set it",
   62.               "   dz= ............... read from model file: if dz==0 then dz= can be used to set it",
   63.               "   dt= ............... read from file_src: if dt==0 then dt= can be used to set it",
   64.               "" ,
   65.               " OPTIONAL PARAMETERS:",
   66.               "   ischeme=3 ......... 1=acoustic, 2=visco-acoustic 3=elastic, 4=visco-elastic",
   67.               "   tmod=(nt-1)*dt .... total registration time (nt from file_src)",
   68.               "   ntaper=0 .......... length of taper at edges of model",
   69.               "   tapfact=0.30 ...... taper strength: larger value gets stronger taper",
   70.               "   For the 4 boundaries the options are:  1=free 2=pml 3=rigid 4=taper",
   71.               "   top=1 ............. type of boundary on top edge of model",
   72.               "   left=4 ............ type of boundary on left edge of model",
   73.               "   right=4 ........... type of boundary on right edge of model",
   74.               "   bottom=4 .......... type of boundary on bottom edge of model",
   75.               //"   tapleft=0 ......... =1: taper left edge of model",
   76.               //"   tapright=0 ........ =1: taper right edge of model",
   77.               //"   taptop=0 .......... =1: taper top edge of model",
   78.               //"   tapbottom=0 ....... =1: taper bottom edge of model",
   79.               //"   cfree=0 ........... 1=free surface",
   80.               "   grid_dir=0 ........ direction of time modeling (1=reverse time)",
   81.               "   Qp=15 ............. global Q-value for P-waves in visco-elastic (ischeme=2,4)",
   82.               "   file_qp= .......... model file Qp values as function of depth",
   83.               "   Qs=Qp ............. global Q-value for S-waves in visco-elastic (ischeme=4)",
   84.               "   file_qs= .......... model file Qs values as function of depth",
   85.               "   fw=0.5*fmax ....... central frequency for which the Q's are used",
   86.               "   sinkdepth=0 ....... receiver grid points below topography (defined bij cp=0.0)",
   87.               "   sinkdepth_src=0 ... source grid points below topography (defined bij cp=0.0)",
   88.               "   sinkvel=0 ......... use velocity of first receiver to sink through to next layer",
   89.               "   beam=0 ............ calculate energy beam of wavefield in model",
   90.               "   disable_check=0 ... disable stabilty and dispersion check and continue modeling",
   91.               "   verbose=0 ......... silent mode; =1: display info",
   92.               " ",
   93.               " SHOT AND GENERAL SOURCE DEFINITION:",
   94.               "   src_type=1 ........ 1=P 2=Txz 3=Tzz 4=Txx 5=S-pot 6=Fx 7=Fz 8=P-pot 9=P+(Fx and/or Fz)",
   95.               "",
   96.               "      Jan Thorbecke 2015",
   97.               "      Cray / TU Delft",
   98.               "      E-mail: janth@xs4all.nl ",
   99.               "",
  100.               NULL};
  101.               
  102.               int main (int argc, char *argv[])
  103.               {
  104.               	modPar mod;
  105.               	recPar rec;
  106.               	snaPar sna;
  107.               	wavPar wav;
  108.               	srcPar src;
  109.               	bndPar bnd;
  110.               	shotPar shot;
  111.               	float *wavelet;
  112.               	int nx, ny, nz, dims[3], period[3], reorder, coord[3], ndims=3;
  113.               	int npx, npy, npz, halo, nt;
  114.               	int my_rank, size, source, dest, snapwritten;
  115.               	int left, right, front, back, top, bottom;
  116.               	int direction, displ, halosizex, halosizey, halosizez;
  117.               	int ioXx, ioXz, ioYx, ioYz, ioZz, ioZx, ioPx, ioPz;
  118.               	int it, ix, iy, iz, iyp, ixp, izp, isrc, ixsrc, iysrc, izsrc, c1, c2;
  119.               	int sizes[3], subsizes[3], starts[3];
  120.               	int gsizes[3], gsubsizes[3], gstarts[3];
  121.               	int error, rc, verbose;
  122.               	float fx, fy, fz, dx, dy, dz, flx, fly, flz;
  123.               	float *p, *vx, *vy, *vz, *ro, *roz, *l2m, hcp, hro, fac;
  124.               	float *leftRecv, *leftSend, *rightRecv, *rightSend;
  125.               	float *frontRecv, *frontSend, *backRecv, *backSend;
  126.               	float *topRecv, *topSend, *bottomRecv, *bottomSend;
  127.               	float dt, src_ampl, fmax, fpeaksrc, t0src, time, snaptime;
  128.               	double t00, t0, t1, t2, tcomm, tcomp, thcomp, tcopy, ttot, tio;
  129.               	char err_buffer[MPI_MAX_ERROR_STRING];
  130.               	int resultlen;
  131.               	MPI_Comm COMM_CART;
  132.               	MPI_Request reqSend[6], reqRecv[6];
  133.               	MPI_Status status[12];
  134.               	MPI_Datatype local_array, global_array;
  135.               	MPI_Offset disp;
  136.               	MPI_Info fileinfo;
  137.               	MPI_File fh;
  138.               	char filename[1000];
  139.               
  140.  +            	MPI_Init(&argc, &argv);
  141.  +            	MPI_Comm_rank(MPI_COMM_WORLD, &my_rank);
  142.  +            	MPI_Comm_size(MPI_COMM_WORLD, &size);
  143.  +            	vinit();
  144.               
  145.  +            	t0= wallclock_time();
  146.  +            	initargs(argc,argv);
  147.  +            	requestdoc(0);
  148.               
  149.  +            	if (!getparint("verbose",&verbose)) verbose=0;
  150.  +            	getParameters(&mod, &rec, &sna, &wav, &src, &shot, &bnd, verbose);
  151.               
  152.               	/* divide 3D cube among available processors */
  153.               	dims[0]=0; 
  154.               	dims[1]=0;
  155.               	dims[2]=0;
  156.  +            	MPI_Dims_create(size, ndims, dims);
  157.               
  158.               	/* dims contains the number of MPI-tasks in each direction */
  159.               	/* set number of grid points based on number of procs in dims */
  160.               	nx=2048; ny=2048; nz=1024;
  161.               	nx=1024; ny=1024; nz=512;
  162.               	nx=256; ny=256; nz=256;
  163.               
  164.               	nx=mod.nx; ny=mod.ny; nz=mod.nz;
  165.               	dx=mod.dx; dy=mod.dy; dz=mod.dz;
  166.               	dx=5; dy=5; dz=5;
  167.               
  168.               	halo = 2;
  169.               	nz=dims[0]*(nz/dims[0]);
  170.               	nx=dims[1]*(nx/dims[1]); 
  171.               	ny=dims[2]*(ny/dims[2]); 
  172.               
  173.               //	dt=0.001;
  174.               	nt=4096;
  175.               	t0src=0.50;
  176.               	hcp=2000.0;
  177.               	hro=1800.0;
  178.               	tcomm=tcomp=thcomp=tcopy=tio=0.0;
  179.               	/* for stability 10 points per wavelenght */
  180.               	fmax=hcp/(dx*8);
  181.               	dt=0.295*dx/hcp;
  182.               	fpeaksrc=0.2*fmax; /* Ricker wavelet has peak at 1/3 of fmax */
  183.               	fac = dt/dx;
  184.               
  185.               
  186.               	fx=-dx*nx/2; fy=-dy*ny/2; fz=0;
  187.               	npz = 2*halo+nz/dims[0];
  188.               	npx = 2*halo+nx/dims[1];
  189.               	npy = 2*halo+ny/dims[2];
  190.               	wavelet = (float *)calloc(nt,sizeof(float));
  191.               
  192.               	snaptime = t0src+1.80*npx*dx*0.5/hcp;
  193.               	snapwritten=0;
  194.               	nt = (int) 1.1*(t0src+snaptime)/dt;
  195.               	nt = (int) (t0src+1.5)/dt;
  196.               
  197.               	if (verbose && my_rank==0) {
  198.               		fprintf(stderr,"fmax=%f fpeak=%f dt=%e\n", fmax, fpeaksrc, dt);
  199.               		fprintf(stderr,"nx=%d nprocx=%d ny=%d nprocy=%d nz=%d nprocz=%d\n", nx, dims[1], ny, dims[2], nz, dims[0]);
  200.               		fprintf(stderr,"npx=%d npy=%d npz=%d nt=%d time=%f\n", npx, npy, npz, nt, nt*dt);
  201.               		fprintf(stderr,"source expected at local boundary at %f seconds\n", npx*dx*0.5/hcp);
  202.  +            		fflush(stderr);
  203.               	}
  204.               
  205.               	if (my_rank==0) fprintf(stderr,"memory per MPI task is %ld MB\n", (6*npx*npy*npz*4/(1024*1024)));
  206.               	/* allocate wavefields and medium properties for local grid domains */
  207.               	p   = (float *)calloc(npx*npy*npz,sizeof(float));
  208.               	vx  = (float *)calloc(npx*npy*npz,sizeof(float));
  209.               	vy  = (float *)calloc(npx*npy*npz,sizeof(float));
  210.               	vz  = (float *)calloc(npx*npy*npz,sizeof(float));
  211.               	ro = (float *)calloc(npx*npy*npz,sizeof(float));
  212.               	l2m = (float *)calloc(npx*npy*npz,sizeof(float));
  213.               
  214.               	/* define homogeneus model */
  215.    Vcr2-----< 	for (ix=0; ix<npx*npy*npz; ix++) {
  216.    Vcr2       		ro[ix]  = fac/hro;
  217.    Vcr2       		l2m[ix] = fac*hcp*hcp*hro;
  218.    Vcr2-----> 	}
  219.               
  220.               	/* create cartesian domain decomposition */
  221.               	period[0]=0; 
  222.               	period[1]=0;
  223.               	period[2]=0;
  224.               	reorder=0;
  225.  +            	MPI_Cart_create(MPI_COMM_WORLD, 3, dims, period, reorder, &COMM_CART);
  226.               
  227.               	/* find out coordinates of the rank */
  228.  +            	MPI_Cart_coords(COMM_CART, my_rank, 3, coord);
  229.               	flz = fz+(dz*nz/dims[0])*coord[0];
  230.               	flx = fx+(dx*nx/dims[1])*coord[1];
  231.               	fly = fy+(dy*ny/dims[2])*coord[2];
  232.               	if (verbose>=2) fprintf(stderr,"Rank %d coordinates are %d %d %d orig=(%5.2F, %5.2f, %5.2f) \n", my_rank, coord[0], coord[1], coord[2], flx, fly, flz);
  233.  +            	fflush(stderr);
  234.               
  235.               	/* find out neighbours of the rank, MPI_PROC_NULL is a hard boundary of the model */ 
  236.               	displ=1;
  237.  +            	MPI_Cart_shift(COMM_CART, 1, 1, &left, &right);
  238.  +            	MPI_Cart_shift(COMM_CART, 2, 1, &top, &bottom);
  239.  +            	MPI_Cart_shift(COMM_CART, 0, 1, &front, &back);
  240.               	if (verbose>=2) fprintf(stderr, "Rank %d in direction 0 has LR neighbours %d %d FB %d %d TB %d %d\n", my_rank, left, right, front, back, top, bottom);
  241.  +            	fflush(stderr);
  242.               
  243.               	/* allocate of halo areas */
  244.               	halosizex = npy*npz*halo;
  245.               	leftRecv  = (float *)calloc(3*halosizex,sizeof(float));
  246.               	rightRecv = (float *)calloc(3*halosizex,sizeof(float));
  247.               	leftSend  = (float *)calloc(3*halosizex,sizeof(float));
  248.               	rightSend = (float *)calloc(3*halosizex,sizeof(float));
  249.               
  250.               	halosizey = npx*npz*halo;
  251.               	frontRecv = (float *)calloc(3*halosizey,sizeof(float));
  252.               	backRecv  = (float *)calloc(3*halosizey,sizeof(float));
  253.               	frontSend = (float *)calloc(3*halosizey,sizeof(float));
  254.               	backSend  = (float *)calloc(3*halosizey,sizeof(float));
  255.               
  256.               	halosizez = npy*npx*halo;
  257.               	topRecv    = (float *)calloc(3*halosizez,sizeof(float));
  258.               	bottomRecv = (float *)calloc(3*halosizez,sizeof(float));
  259.               	topSend    = (float *)calloc(3*halosizez,sizeof(float));
  260.               	bottomSend = (float *)calloc(3*halosizez,sizeof(float));
  261.               
  262.               	if (my_rank==0) fprintf(stderr,"memory per MPI task for halo exchange is %ld MB\n", ((12*(halosizex+halosizey+halosizez))*4/(1024*1024)));
  263.               
  264.               	/* create subarrays(excluding halo areas) to write to file with MPI-IO */
  265.               	/* data in the local array */
  266.               	sizes[0]=npz; 
  267.               	sizes[1]=npx; 
  268.               	sizes[2]=npy;
  269.               	subsizes[0]=sizes[0]-2*halo; 
  270.               	subsizes[1]=sizes[1]-2*halo;  
  271.               	subsizes[2]=sizes[2]-2*halo;
  272.               	starts[0]=halo; 
  273.               	starts[1]=halo; 
  274.               	starts[2]=halo; 
  275.  +            	MPI_Type_create_subarray(3, sizes, subsizes, starts, MPI_ORDER_C, 
  276.                                           MPI_FLOAT, &local_array); 
  277.  +            	MPI_Type_commit(&local_array);
  278.               
  279.               	/* data in the global array */
  280.               	gsizes[0]=nz; 
  281.               	gsizes[1]=nx; 
  282.               	gsizes[2]=ny;
  283.               	gsubsizes[0]=subsizes[0]; 
  284.               	gsubsizes[1]=subsizes[1];  
  285.               	gsubsizes[2]=subsizes[2];
  286.               	gstarts[0]=subsizes[0]*coord[0]; 
  287.               	gstarts[1]=subsizes[1]*coord[1]; 
  288.               	gstarts[2]=subsizes[2]*coord[2]; 
  289.  +            	MPI_Type_create_subarray(3, gsizes, gsubsizes, gstarts, MPI_ORDER_C, 
  290.                                           MPI_FLOAT, &global_array); 
  291.  +            	MPI_Type_commit(&global_array);
  292.               
  293.               
  294.               	/* compute field of the inner grid excluding halo areas */
  295.               	ioXx=2;
  296.               	ioXz=ioXx-1;
  297.               	ioYx=2;
  298.               	ioYz=ioYx-1;
  299.               	ioZz=2;
  300.               	ioZx=ioZz-1;
  301.               	ioPx=1;
  302.               	ioPz=ioPx;
  303.               
  304.  +            	t00 = wallclock_time();
  305.  + VFr4-----< 	for (it=0; it<nt; it++) {
  306.    VFr4       		time = it*dt;
  307.  + VFr4  I--> 		wavelet[it] = gauss2time(time,fpeaksrc,t0src);
  308.    VFr4-----> 	}
  309.               	if (my_rank==0) {
  310.               		FILE *fp;
  311.  +            		fp = fopen("src.bin", "w+");
  312.  +            		fwrite( wavelet, sizeof(float), nt, fp);
  313.  +            		fflush(fp);
  314.  +            		fclose(fp);
  315.               	}
  316.               
  317.               /*
  318.               	nt =1;
  319.               			sprintf(filename,"snap_nz%d_nx%d_ny%d.bin",nz, nx, ny);
  320.               
  321.               	for (ix=0; ix<npx*npy*npz; ix++) {
  322.               		p[ix]  = my_rank;
  323.               	}
  324.               			MPI_Info_create(&fileinfo);
  325.               			MPI_Info_set(fileinfo, "striping_factor", STRIPE_COUNT);
  326.               			MPI_Info_set(fileinfo, "striping_unit", STRIPE_SIZE);
  327.               			MPI_File_delete(filename, MPI_INFO_NULL);
  328.               			rc = MPI_File_open(MPI_COMM_WORLD, filename, MPI_MODE_RDWR|MPI_MODE_CREATE, fileinfo, &fh);
  329.               			if (rc != MPI_SUCCESS) {
  330.                 				fprintf(stderr, "could not open input file\n");
  331.                 				MPI_Abort(MPI_COMM_WORLD, 2);
  332.               			}
  333.               			disp = 0;
  334.               			rc = MPI_File_set_view(fh, disp, MPI_FLOAT, global_array, "native", fileinfo);
  335.               			if (rc != MPI_SUCCESS) {
  336.               				fprintf(stderr, "error setting view on results file\n");
  337.               				MPI_Abort(MPI_COMM_WORLD, 4);
  338.               			}
  339.               			rc = MPI_File_write_all(fh, p, 1, local_array, status);
  340.               			if (rc != MPI_SUCCESS) {
  341.               				MPI_Error_string(rc,err_buffer,&resultlen);
  342.               				fprintf(stderr,err_buffer);
  343.               				MPI_Abort(MPI_COMM_WORLD, 5);
  344.               			}
  345.               			MPI_File_close(&fh);
  346.               */
  347.               
  348.               
  349.               	/* Main loop over the number of time steps */
  350.  + 1--------< 	for (it=0; it<nt; it++) {
  351.  + 1          		t0 = wallclock_time();
  352.  + 1          		time = it*dt;
  353.    1          		//fprintf(stderr,"modeling time step %d for time %f\n", it, time);
  354.    1          
  355.    1          		/* define source wavelet */
  356.  + 1          		wavelet[it] = gauss2time(time,fpeaksrc,t0src);
  357.    1          
  358.    1          		/* update of grid values on halo areas */
  359.  + 1          		updateVelocitiesHalo(vx, vy, vz, p, ro, halo, npx, npy, npz);
  360.  + 1          		t1 = wallclock_time();
  361.    1          		thcomp += t1-t0;
  362.    1          
  363.    1          		/* copy of halo areas  */
  364.  + 1          		copyHaloVxVz(vx, vz, npx, npy, npz, halo, leftSend, rightSend, frontSend, backSend, topSend, bottomSend);
  365.  + 1          		t2 = wallclock_time();
  366.    1          		tcopy += t2-t1;
  367.    1          
  368.    1          		/* start a-synchronous communication of halo areas to neighbours */
  369.    1          		/* this is done first for Vx,Vz fields only */
  370.  + 1          		exchangeHalo(leftRecv, leftSend, rightRecv, rightSend, 2*halosizex, left, right, &reqRecv[0], &reqSend[0], 0);
  371.  + 1          		exchangeHalo(frontRecv, frontSend, backRecv, backSend, 2*halosizey, front, back, &reqRecv[2], &reqSend[2], 4);
  372.  + 1          		exchangeHalo(topRecv, topSend, bottomRecv, bottomSend, 2*halosizez, top, bottom, &reqRecv[4], &reqSend[4], 8);
  373.  + 1          		t1 = wallclock_time();
  374.    1          		tcomm += t1-t2;
  375.    1          
  376.    1          		/* compute update on grid values excluding halo areas */
  377.  + 1          		updateVelocities(vx, vy, vz, p, ro, halo, npx, npy, npz);
  378.  + 1          		t2 = wallclock_time();
  379.    1          		tcomp += t2-t1;
  380.    1          
  381.    1          		/* wait for Vx.Vz halo exchange */
  382.  + 1          		waitForHalo(&reqRecv[0], &reqSend[0]);
  383.  + 1          		t1 = wallclock_time();
  384.    1          		tcomm += t1-t2;
  385.    1          
  386.    1          		/* copy of halo areas  back to arrays */
  387.  + 1          		newHaloVxVz(vx, vz, npx, npy, npz, halo, leftRecv, rightRecv, frontRecv, backRecv, topRecv, bottomRecv);
  388.  + 1          		t2 = wallclock_time();
  389.    1          		tcopy += t2-t1;
  390.    1          	
  391.    1          		/* add Force source on the Vz grid */
  392.    1          		src_ampl = wavelet[it];
  393.    1          	
  394.    1          		/* check if source position is in local domain */
  395.    1          		/* for the moment place a source in the middle of each domain */
  396.    1          		ixsrc = npx/2;
  397.    1          		iysrc = npy/2;
  398.    1          		izsrc = npz/2;
  399.    1          		isrc  = iysrc*npx*npz+ixsrc*npz+izsrc;
  400.    1          //		fprintf(stderr,"npz=%d npx=%d npy=%d isrc=%d\n", npz, npx, npy, isrc);
  401.    1          	
  402.    1          		/* source scaling factor to compensate for discretisation */
  403.    1          		src_ampl *= ro[isrc]*l2m[isrc]/(dt);
  404.    1          	
  405.    1          		/* Force source */
  406.    1          		if (my_rank == 0) vz[isrc] += 0.25*src_ampl*ro[isrc]*dz;
  407.    1          	
  408.    1          		/* compute field on the grid of the halo areas */
  409.  + 1          		updatePressureHalo(vx, vy, vz, p, l2m, halo, npx, npy, npz);
  410.  + 1          		t1 = wallclock_time();
  411.    1          		thcomp += t1-t2;
  412.    1          
  413.    1          		/* copy p-field and sent to neighbours */
  414.  + 1          		copyHaloP(p, npx, npy, npz, halo, leftSend, rightSend, frontSend, backSend, topSend, bottomSend);
  415.  + 1          		exchangeHalo(leftRecv, leftSend, rightRecv, rightSend, halosizex, left, right, &reqRecv[0], &reqSend[0], 0);
  416.  + 1          		exchangeHalo(frontRecv, frontSend, backRecv, backSend, halosizey, front, back, &reqRecv[2], &reqSend[2], 4);
  417.  + 1          		exchangeHalo(topRecv, topSend, bottomRecv, bottomSend, halosizez, top, bottom, &reqRecv[4], &reqSend[4], 8);
  418.  + 1          		t2 = wallclock_time();
  419.    1          		tcomm += t2-t1;
  420.    1          
  421.    1          		/* compute update on grid values excluding halo areas */
  422.  + 1          		updatePressure(vx, vy, vz, p, l2m, halo, npx, npy, npz);
  423.  + 1          		t1 = wallclock_time();
  424.    1          		tcomp += t1-t2;
  425.    1          
  426.    1          		/* wait for P halo exchange */
  427.  + 1          		waitForHalo(&reqRecv[0], &reqSend[0]);
  428.  + 1          		t2 = wallclock_time();
  429.    1          		tcomm += t2-t1;
  430.    1          
  431.  + 1          		newHaloP(p, npx, npy, npz, halo, leftRecv, rightRecv, frontRecv, backRecv, topRecv, bottomRecv);
  432.  + 1          		t1 = wallclock_time();
  433.    1          		tcopy += t1-t2;
  434.    1          	
  435.    1          //		fprintf(stderr,"rank %d did time step %d in %f seconds\n", my_rank, it, t1-t0);
  436.    1          //		fflush(stderr);
  437.    1          
  438.    1          		/* write snapshots to file */
  439.    1          //		if (time >= snaptime && !snapwritten) {
  440.    1          		if ((it+1)%100==0 ) {
  441.    1          
  442.  + 1          			t1 = wallclock_time();
  443.  + 1          			sprintf(filename,"snap_nz%d_nx%d_ny%d_it%4d.bin",nz, nx, ny, it);
  444.    1          
  445.  + 1          			MPI_Info_create(&fileinfo);
  446.  + 1          			MPI_Info_set(fileinfo, "striping_factor", STRIPE_COUNT);
  447.  + 1          			MPI_Info_set(fileinfo, "striping_unit", STRIPE_SIZE);
  448.  + 1          			MPI_File_delete(filename, MPI_INFO_NULL);
  449.  + 1          			rc = MPI_File_open(MPI_COMM_WORLD, filename, MPI_MODE_RDWR|MPI_MODE_CREATE, fileinfo, &fh);
  450.    1          			if (rc != MPI_SUCCESS) {
  451.    1            				fprintf(stderr, "could not open input file\n");
  452.  + 1            				MPI_Abort(MPI_COMM_WORLD, 2);
  453.    1          			}
  454.    1          			disp = 0;
  455.  + 1          			rc = MPI_File_set_view(fh, disp, MPI_FLOAT, global_array, "native", fileinfo);
  456.    1          			if (rc != MPI_SUCCESS) {
  457.    1          				fprintf(stderr, "error setting view on results file\n");
  458.  + 1          				MPI_Abort(MPI_COMM_WORLD, 4);
  459.    1          			}
  460.  + 1          			rc = MPI_File_write_all(fh, p, 1, local_array, status);
  461.    1          			if (rc != MPI_SUCCESS) {
  462.  + 1          				MPI_Error_string(rc,err_buffer,&resultlen);
  463.    1          				fprintf(stderr,err_buffer);
  464.  + 1          				MPI_Abort(MPI_COMM_WORLD, 5);
  465.    1          			}
  466.  + 1          			MPI_File_close(&fh);
  467.    1          
  468.    1          
  469.    1          /*			MPI_Info_create(&fileinfo);
  470.    1          			MPI_File_delete(filename, MPI_INFO_NULL);
  471.    1          			MPI_File_open(MPI_COMM_WORLD, filename, MPI_MODE_RDWR|MPI_MODE_CREATE, MPI_INFO_NULL, &fh);
  472.    1          			MPI_File_set_view(fh, 0, MPI_FLOAT, global_array, "native", MPI_INFO_NULL);
  473.    1          			MPI_File_write_all(fh, p, npz*npx*npy, local_array, status);
  474.    1          			MPI_File_close(&fh);
  475.    1          */
  476.    1          			snapwritten+=1;
  477.  + 1          			t2 = wallclock_time();
  478.    1          			tio += t2-t1;
  479.    1          		}
  480.    1          
  481.    1--------> 	}
  482.  +            	ttot = wallclock_time() - t00;
  483.               
  484.               	if (my_rank == 0) {
  485.               		fprintf(stderr,"rank %d total time in %f seconds\n", my_rank, ttot);
  486.               		fprintf(stderr,"rank %d comm  time in %f seconds\n", my_rank, tcomm);
  487.               		fprintf(stderr,"rank %d comp  time in %f seconds\n", my_rank, tcomp);
  488.               		fprintf(stderr,"rank %d hcomp time in %f seconds\n", my_rank, thcomp);
  489.               		fprintf(stderr,"rank %d copy  time in %f seconds\n", my_rank, tcopy);
  490.               		fprintf(stderr,"rank %d io    time in %f seconds\n", my_rank, tio);
  491.               		fprintf(stderr,"rank %d snaphsots written to file\n", my_rank, snapwritten);
  492.               	}
  493.               
  494.               
  495.  +            	MPI_Finalize();
  496.               	return 0;
  497.               }
  498.               
  499.               
  500.               
  501.               int updateVelocities(float *vx, float *vy, float *vz, float *p, float *ro, int halo, int npx, int npy, int npz)
  502.               {
  503.               	int ix, iy, iz, iyp, ixp, izp, c1, c2, nxz;
  504.               	int ixs, ixe, iys, iye, izs, ize;
  505.               	float DpDx, DpDy, DpDz;
  506.               
  507.               	nxz=npx*npz;
  508.               	c1 = 9.0/8.0;
  509.               	c2 = -1.0/24.0;
  510.               
  511.               	ixs=2*halo; ixe=npx-2*halo;
  512.               	iys=2*halo; iye=npy-2*halo;
  513.               	izs=2*halo; ize=npz-2*halo;
  514.               
  515.               	/* calculate vx,vy,vz for all grid points except on the virtual boundary*/
  516.               #pragma omp for private (iy, ix, iz) nowait
  517.               #pragma ivdep
  518.  + 1--------< 	for (iy=iys; iy<iye; iy++) {
  519.    1          		iyp=iy*nxz;
  520.  + 1 2------< 		for (ix=ixs; ix<ixe; ix++) {
  521.    1 2        			ixp=ix*npz;
  522.    1 2        #pragma ivdep
  523.    1 2 Vr2--< 			for (iz=izs; iz<ize; iz++) {
  524.    1 2 Vr2    				DpDx = Dx(p,ix,iyp,iz,npz);
  525.    1 2 Vr2    				DpDy = Dy(p,ixp,iy,iz,nxz);
  526.    1 2 Vr2    				DpDz = Dz(p,ixp,iyp,iz);
  527.    1 2 Vr2    
  528.    1 2 Vr2    				vz[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDz;
  529.    1 2 Vr2    				vx[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDx;
  530.    1 2 Vr2    				vy[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDy;
  531.    1 2 Vr2--> 			}
  532.    1 2------> 		}
  533.    1--------> 	}
  534.               
  535.               	return 0;
  536.               }
  537.               
  538.               int updateVelocitiesHalo(float *vx, float *vy, float *vz, float *p, float *ro, int halo, int npx, int npy, int npz)
  539.               {
  540.               	int ix, iy, iz, iyp, ixp, izp, c1, c2, nxz;
  541.               	float DpDx, DpDy, DpDz;
  542.               
  543.               	nxz=npx*npz;
  544.               	c1 = 9.0/8.0;
  545.               	c2 = -1.0/24.0;
  546.               
  547.               	/* calculate vx,vy,vz for all halo grid points */
  548.               
  549.               	/* compute halo areas at left side */
  550.               #pragma omp for private (iy, ix, iz) nowait
  551.  + 1--------< 	for (iy=halo; iy<npy-halo; iy++) {
  552.    1          		iyp=iy*nxz;
  553.  + 1 2------< 		for (ix=halo; ix<2*halo; ix++) {
  554.    1 2        			ixp=ix*npz;
  555.    1 2        #pragma ivdep
  556.    1 2 Vr2--< 			for (iz=halo; iz<npz-halo; iz++) {
  557.    1 2 Vr2    				DpDx = Dx(p,ix,iyp,iz,npz);
  558.    1 2 Vr2    				DpDy = Dy(p,ixp,iy,iz,nxz);
  559.    1 2 Vr2    				DpDz = Dz(p,ixp,iyp,iz);
  560.    1 2 Vr2    
  561.    1 2 Vr2    				vz[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDz;
  562.    1 2 Vr2    				vx[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDx;
  563.    1 2 Vr2    				vy[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDy;
  564.    1 2 Vr2--> 			}
  565.    1 2------> 		}
  566.    1--------> 	}
  567.               
  568.               	/* compute halo areas at right side */
  569.  + 1--------< 	for (iy=halo; iy<npy-halo; iy++) {
  570.    1          		iyp=iy*nxz;
  571.  + 1 2------< 		for (ix=npx-2*halo; ix<npx-halo; ix++) {
  572.    1 2        			ixp=ix*npz;
  573.    1 2        #pragma ivdep
  574.    1 2 Vr2--< 			for (iz=halo; iz<npz-halo; iz++) {
  575.    1 2 Vr2    				DpDx = Dx(p,ix,iyp,iz,npz);
  576.    1 2 Vr2    				DpDy = Dy(p,ixp,iy,iz,nxz);
  577.    1 2 Vr2    				DpDz = Dz(p,ixp,iyp,iz);
  578.    1 2 Vr2    
  579.    1 2 Vr2    				vz[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDz;
  580.    1 2 Vr2    				vx[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDx;
  581.    1 2 Vr2    				vy[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDy;
  582.    1 2 Vr2--> 			}
  583.    1 2------> 		}
  584.    1--------> 	}
  585.               
  586.               
  587.               	/* compute halo areas at front side */
  588.  + 1--------< 	for (iy=halo; iy<2*halo; iy++) {
  589.    1          		iyp=iy*nxz;
  590.  + 1 2------< 		for (ix=2*halo; ix<npx-2*halo; ix++) {
  591.    1 2        			ixp=ix*npz;
  592.    1 2        #pragma ivdep
  593.    1 2 Vr2--< 			for (iz=halo; iz<npz-halo; iz++) {
  594.    1 2 Vr2    				DpDx = Dx(p,ix,iyp,iz,npz);
  595.    1 2 Vr2    				DpDy = Dy(p,ixp,iy,iz,nxz);
  596.    1 2 Vr2    				DpDz = Dz(p,ixp,iyp,iz);
  597.    1 2 Vr2    
  598.    1 2 Vr2    				vz[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDz;
  599.    1 2 Vr2    				vx[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDx;
  600.    1 2 Vr2    				vy[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDy;
  601.    1 2 Vr2--> 			}
  602.    1 2------> 		}
  603.    1--------> 	}
  604.               
  605.               	/* compute halo areas at back side */
  606.  + 1--------< 	for (iy=npy-2*halo; iy<npy-halo; iy++) {
  607.    1          		iyp=iy*nxz;
  608.  + 1 2------< 		for (ix=2*halo; ix<npx-2*halo; ix++) {
  609.    1 2        			ixp=ix*npz;
  610.    1 2        #pragma ivdep
  611.    1 2 Vr2--< 			for (iz=halo; iz<npz-halo; iz++) {
  612.    1 2 Vr2    				DpDx = Dx(p,ix,iyp,iz,npz);
  613.    1 2 Vr2    				DpDy = Dy(p,ixp,iy,iz,nxz);
  614.    1 2 Vr2    				DpDz = Dz(p,ixp,iyp,iz);
  615.    1 2 Vr2    
  616.    1 2 Vr2    				vz[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDz;
  617.    1 2 Vr2    				vx[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDx;
  618.    1 2 Vr2    				vy[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDy;
  619.    1 2 Vr2--> 			}
  620.    1 2------> 		}
  621.    1--------> 	}
  622.               
  623.               	/* compute halo areas at top side */
  624.  + 1--------< 	for (iy=2*halo; iy<npy-2*halo; iy++) {
  625.    1          		iyp=iy*nxz;
  626.  + 1 2------< 		for (ix=2*halo; ix<npx-2*halo; ix++) {
  627.    1 2        			ixp=ix*npz;
  628.    1 2        #pragma ivdep
  629.    1 2 Vr2--< 			for (iz=halo; iz<2*halo; iz++) {
  630.    1 2 Vr2    				DpDx = Dx(p,ix,iyp,iz,npz);
  631.    1 2 Vr2    				DpDy = Dy(p,ixp,iy,iz,nxz);
  632.    1 2 Vr2    				DpDz = Dz(p,ixp,iyp,iz);
  633.    1 2 Vr2    
  634.    1 2 Vr2    				vz[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDz;
  635.    1 2 Vr2    				vx[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDx;
  636.    1 2 Vr2    				vy[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDy;
  637.    1 2 Vr2--> 			}
  638.    1 2------> 		}
  639.    1--------> 	}
  640.               
  641.               	/* compute halo areas at bottom side */
  642.  + 1--------< 	for (iy=2*halo; iy<npy-2*halo; iy++) {
  643.    1          		iyp=iy*nxz;
  644.  + 1 2------< 		for (ix=2*halo; ix<npx-2*halo; ix++) {
  645.    1 2        			ixp=ix*npz;
  646.    1 2        #pragma ivdep
  647.    1 2 Vr2--< 			for (iz=npz-2*halo; iz<npz-halo; iz++) {
  648.    1 2 Vr2    				DpDx = Dx(p,ix,iyp,iz,npz);
  649.    1 2 Vr2    				DpDy = Dy(p,ixp,iy,iz,nxz);
  650.    1 2 Vr2    				DpDz = Dz(p,ixp,iyp,iz);
  651.    1 2 Vr2    
  652.    1 2 Vr2    				vz[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDz;
  653.    1 2 Vr2    				vx[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDx;
  654.    1 2 Vr2    				vy[iyp+ixp+iz] += ro[iyp+ixp+iz]*DpDy;
  655.    1 2 Vr2--> 			}
  656.    1 2------> 		}
  657.    1--------> 	}
  658.               
  659.               	return 0;
  660.               }
  661.               
  662.               int updatePressure(float *vx, float *vy, float *vz, float *p, float *l2m, int halo, int npx, int npy, int npz)
  663.               {
  664.               	int ix, iy, iz, iyp, ixp, izp, c1, c2, nxz;
  665.               	int ixs, ixe, iys, iye, izs, ize;
  666.               
  667.               	nxz=npx*npz;
  668.               	c1 = 9.0/8.0;
  669.               	c2 = -1.0/24.0;
  670.               
  671.               	ixs=2*halo; ixe=npx-2*halo;
  672.               	iys=2*halo; iye=npy-2*halo;
  673.               	izs=2*halo; ize=npz-2*halo;
  674.               
  675.               /* calculate p/tzz for all grid points except on the virtual boundary */
  676.               #pragma omp for private (ix, iz)
  677.               #pragma ivdep
  678.  + 1--------< 	for (iy=iys; iy<iye; iy++) {
  679.    1          		iyp=iy*nxz;
  680.  + 1 2------< 		for (ix=ixs; ix<ixe; ix++) {
  681.    1 2        			ixp=ix*npz;
  682.    1 2        #pragma ivdep
  683.    1 2 V----< 			for (iz=izs; iz<ize; iz++) {
  684.    1 2 V      				p[iyp+ixp+iz] += l2m[iyp+ixp+iz]*(Dv(vx,vz,ix,iy,iz,npz,nxz));
  685.    1 2 V----> 			}
  686.    1 2------> 		}
  687.    1--------> 	}
  688.               
  689.               	return 0;
  690.               }
  691.               
  692.               int updatePressureHalo(float *vx, float *vy, float *vz, float *p, float *l2m, int halo, int npx, int npy, int npz)
  693.               {
  694.               	int ix, iy, iz, iyp, ixp, izp, c1, c2, nxz;
  695.               
  696.               	nxz=npx*npz;
  697.               	c1 = 9.0/8.0;
  698.               	c2 = -1.0/24.0;
  699.               
  700.               	/* calculate p/tzz for all grid points except on the virtual boundary */
  701.               
  702.               	/* compute halo areas at left side */
  703.               #pragma omp for private (iy, ix, iz) nowait
  704.  + 1--------< 	for (iy=halo; iy<npy-halo; iy++) {
  705.    1          		iyp=iy*nxz;
  706.  + 1 2------< 		for (ix=halo; ix<2*halo; ix++) {
  707.    1 2        			ixp=ix*npz;
  708.    1 2        #pragma ivdep
  709.    1 2 V----< 			for (iz=halo; iz<npz-halo; iz++) {
  710.    1 2 V      				p[iyp+ixp+iz] += l2m[iyp+ixp+iz]*(Dv(vx,vz,ix,iy,iz,npz,nxz));
  711.    1 2 V----> 			}
  712.    1 2------> 		}
  713.    1--------> 	}
  714.               
  715.               	/* compute halo areas at right side */
  716.  + 1--------< 	for (iy=halo; iy<npy-halo; iy++) {
  717.    1          		iyp=iy*nxz;
  718.  + 1 2------< 		for (ix=npx-2*halo; ix<npx-halo; ix++) {
  719.    1 2        			ixp=ix*npz;
  720.    1 2        #pragma ivdep
  721.    1 2 V----< 			for (iz=halo; iz<npz-halo; iz++) {
  722.    1 2 V      				p[iyp+ixp+iz] += l2m[iyp+ixp+iz]*(Dv(vx,vz,ix,iy,iz,npz,nxz));
  723.    1 2 V----> 			}
  724.    1 2------> 		}
  725.    1--------> 	}
  726.               
  727.               
  728.               	/* compute halo areas at front side */
  729.  + 1--------< 	for (iy=halo; iy<2*halo; iy++) {
  730.    1          		iyp=iy*nxz;
  731.  + 1 2------< 		for (ix=2*halo; ix<npx-2*halo; ix++) {
  732.    1 2        			ixp=ix*npz;
  733.    1 2        #pragma ivdep
  734.    1 2 V----< 			for (iz=halo; iz<npz-halo; iz++) {
  735.    1 2 V      				p[iyp+ixp+iz] += l2m[iyp+ixp+iz]*(Dv(vx,vz,ix,iy,iz,npz,nxz));
  736.    1 2 V----> 			}
  737.    1 2------> 		}
  738.    1--------> 	}
  739.               
  740.               	/* compute halo areas at back side */
  741.  + 1--------< 	for (iy=npy-2*halo; iy<npy-halo; iy++) {
  742.    1          		iyp=iy*nxz;
  743.  + 1 2------< 		for (ix=2*halo; ix<npx-2*halo; ix++) {
  744.    1 2        			ixp=ix*npz;
  745.    1 2        #pragma ivdep
  746.    1 2 V----< 			for (iz=halo; iz<npz-halo; iz++) {
  747.    1 2 V      				p[iyp+ixp+iz] += l2m[iyp+ixp+iz]*(Dv(vx,vz,ix,iy,iz,npz,nxz));
  748.    1 2 V----> 			}
  749.    1 2------> 		}
  750.    1--------> 	}
  751.               
  752.               	/* compute halo areas at top side */
  753.  + 1--------< 	for (iy=2*halo; iy<npy-2*halo; iy++) {
  754.    1          		iyp=iy*nxz;
  755.  + 1 2------< 		for (ix=2*halo; ix<npx-2*halo; ix++) {
  756.    1 2        			ixp=ix*npz;
  757.    1 2        #pragma ivdep
  758.    1 2 V----< 			for (iz=halo; iz<2*halo; iz++) {
  759.    1 2 V      				p[iyp+ixp+iz] += l2m[iyp+ixp+iz]*(Dv(vx,vz,ix,iy,iz,npz,nxz));
  760.    1 2 V----> 			}
  761.    1 2------> 		}
  762.    1--------> 	}
  763.               
  764.               	/* compute halo areas at bottom side */
  765.  + 1--------< 	for (iy=2*halo; iy<npy-2*halo; iy++) {
  766.    1          		iyp=iy*nxz;
  767.  + 1 2------< 		for (ix=2*halo; ix<npx-2*halo; ix++) {
  768.    1 2        			ixp=ix*npz;
  769.    1 2        #pragma ivdep
  770.    1 2 V----< 			for (iz=npz-2*halo; iz<npz-halo; iz++) {
  771.    1 2 V      				p[iyp+ixp+iz] += l2m[iyp+ixp+iz]*(Dv(vx,vz,ix,iy,iz,npz,nxz));
  772.    1 2 V----> 			}
  773.    1 2------> 		}
  774.    1--------> 	}
  775.               
  776.               	return 0;
  777.               }
  778.               
  779.               int exchangeHalo(float *leftRecv, float *leftSend, float *rightRecv, float *rightSend, int size, int leftrank, int rightrank, MPI_Request *reqRecv, MPI_Request *reqSend, int tag)
  780.               {
  781.               	int error, my_rank, ltag;
  782.               	MPI_Status status;
  783.               
  784.  +                MPI_Comm_rank(MPI_COMM_WORLD, &my_rank);
  785.               
  786.               	if (leftrank != MPI_PROC_NULL) {
  787.               		ltag = tag;
  788.  +            		error = MPI_Irecv(leftRecv, size, MPI_FLOAT, leftrank, ltag, MPI_COMM_WORLD, &reqRecv[0]);
  789.  +            		assert (error == MPI_SUCCESS);
  790.               //		fprintf(stderr,"rank %d recv data from %d left\n", my_rank, leftrank);
  791.               		ltag = tag+1;
  792.  +            		error = MPI_Isend(leftSend, size, MPI_FLOAT, leftrank, ltag, MPI_COMM_WORLD, &reqSend[0]);
  793.  +            		assert (error == MPI_SUCCESS);
  794.               //		fprintf(stderr,"rank %d send data to %d left\n", my_rank, leftrank);
  795.               	}
  796.               	else {
  797.               		reqRecv[0] = MPI_REQUEST_NULL;
  798.               		reqSend[0] = MPI_REQUEST_NULL;
  799.               	}
  800.               
  801.               	if (rightrank != MPI_PROC_NULL) {
  802.               		ltag = tag+1;
  803.  +            		error = MPI_Irecv(rightRecv, size, MPI_FLOAT, rightrank, ltag, MPI_COMM_WORLD, &reqRecv[1]);
  804.               //		fprintf(stderr,"rank %d recv data from %d right\n", my_rank, rightrank);
  805.  +            		assert (error == MPI_SUCCESS);
  806.               		ltag = tag;
  807.  +            		error = MPI_Isend(rightSend, size, MPI_FLOAT, rightrank, ltag, MPI_COMM_WORLD, &reqSend[1]);
  808.  +            		assert (error == MPI_SUCCESS);
  809.               //		fprintf(stderr,"rank %d send data to %d right\n", my_rank, rightrank);
  810.               	}
  811.               	else {
  812.               		reqRecv[1] = MPI_REQUEST_NULL;
  813.               		reqSend[1] = MPI_REQUEST_NULL;
  814.               	}
  815.               
  816.               	return 0;
  817.               }
  818.               
  819.               int waitForHalo(MPI_Request *reqRecv, MPI_Request *reqSend)
  820.               {
  821.               	int i;
  822.               	MPI_Status status;
  823.               	int error;
  824.               
  825.  + 1--------< 	for (i=0; i<6; i++) {
  826.  + 1          		error = MPI_Wait(&reqSend[i], &status);
  827.  + 1          		assert (error == MPI_SUCCESS);
  828.    1--------> 	}
  829.               
  830.               //	MPI_Barrier(MPI_COMM_WORLD);
  831.               
  832.  + 1--------< 	for (i=0; i<6; i++) {
  833.  + 1          		error = MPI_Wait(&reqRecv[i], &status);
  834.  + 1          		assert (error == MPI_SUCCESS);
  835.    1--------> 	}
  836.               
  837.               	return 0;
  838.               }
  839.               
  840.               int copyHaloVxVz(float *vx, float *vz, int npx, int npy, int npz, int halo, float *leftSend, float *rightSend, float *frontSend, float *backSend, float *topSend, float *bottomSend)
  841.               {
  842.               	int ix, iy, iz, ih, iyp, ixp, halosizex, halosizey, halosizez, nxz;
  843.               
  844.               	nxz = npx*npz;
  845.               
  846.               	/* copy halo areas at left side */
  847.               	halosizex = npy*npz*halo;
  848.  + 1--------< 	for (iy=halo; iy<npy-halo; iy++) {
  849.    1          		iyp=iy*nxz;
  850.  + 1 2------< 		for (ix=halo; ix<2*halo; ix++) {
  851.    1 2        			ixp=ix*npz;
  852.    1 2        			ih=(ix-halo)*npz;
  853.    1 2        #pragma ivdep
  854.    1 2 Vr2--< 			for (iz=halo; iz<npz-halo; iz++) {
  855.    1 2 Vr2    				leftSend[iy*npz*halo+ih+iz]             = vx[iyp+ixp+iz];
  856.    1 2 Vr2    				leftSend[halosizex+iy*npz*halo+ih+iz]   = vz[iyp+ixp+iz];
  857.    1 2 Vr2--> 			}
  858.    1 2------> 		}
  859.    1--------> 	}
  860.               
  861.               	/* copy halo areas at right side */
  862.               	halosizex = npy*npz*halo;
  863.  + 1--------< 	for (iy=halo; iy<npy-halo; iy++) {
  864.    1          		iyp=iy*nxz;
  865.  + 1 2------< 		for (ix=npx-2*halo; ix<npx-halo; ix++) {
  866.    1 2        			ixp=ix*npz;
  867.    1 2        			ih=(ix-(npx-2*halo))*npz;
  868.    1 2        #pragma ivdep
  869.    1 2 Vr2--< 			for (iz=halo; iz<npz-halo; iz++) {
  870.    1 2 Vr2    				rightSend[iy*npz*halo+ih+iz]             = vx[iyp+ixp+iz];
  871.    1 2 Vr2    				rightSend[halosizex+iy*npz*halo+ih+iz]   = vz[iyp+ixp+iz];
  872.    1 2 Vr2--> 			}
  873.    1 2------> 		}
  874.    1--------> 	}
  875.               
  876.               
  877.               	/* copy halo areas at front side */
  878.               	halosizey = npx*npz*halo;
  879.  + C--------< 	for (iy=halo; iy<2*halo; iy++) {
  880.    C          		iyp=iy*nxz;
  881.    C          		ih=(iy-halo)*nxz;
  882.  + C C------< 		for (ix=0; ix<npx; ix++) {
  883.    C C        			ixp=ix*npz;
  884.    C C        #pragma ivdep
  885.    C C Vr2--< 			for (iz=halo; iz<npz-halo; iz++) {
  886.    C C Vr2    				frontSend[ih+ixp+iz]             = vx[iyp+ixp+iz];
  887.    C C Vr2    				frontSend[halosizey+ih+ixp+iz]   = vz[iyp+ixp+iz];
  888.    C C Vr2--> 			}
  889.    C C------> 		}
  890.    C--------> 	}
  891.               
  892.               	/* copy halo areas at back side */
  893.  + C--------< 	for (iy=npy-2*halo; iy<npy-halo; iy++) {
  894.    C          		iyp=iy*nxz;
  895.    C          		ih=(iy-(npy-2*halo))*nxz;
  896.  + C C------< 		for (ix=0; ix<npx; ix++) {
  897.    C C        			ixp=ix*npz;
  898.    C C        #pragma ivdep
  899.    C C Vr2--< 			for (iz=halo; iz<npz-halo; iz++) {
  900.    C C Vr2    				backSend[ih+ixp+iz]             = vx[iyp+ixp+iz];
  901.    C C Vr2    				backSend[halosizey+ih+ixp+iz]   = vz[iyp+ixp+iz];
  902.    C C Vr2--> 			}
  903.    C C------> 		}
  904.    C--------> 	}
  905.               
  906.               	/* copy halo areas at top side */
  907.               	halosizez = npy*npx*halo;
  908.  + C--------< 	for (iy=0; iy<npy; iy++) {
  909.    C          		iyp=iy*nxz;
  910.  + C C------< 		for (ix=0; ix<npx; ix++) {
  911.    C C        			ixp=ix*npz;
  912.    C C        #pragma ivdep
  913.    C C Vr2--< 			for (iz=halo; iz<2*halo; iz++) {
  914.    C C Vr2    				ih=iz-halo;
  915.    C C Vr2    				topSend[iy*npx*halo+ix*halo+ih]             = vx[iyp+ixp+iz];
  916.    C C Vr2    				topSend[halosizez+iy*npx*halo+ix*halo+ih]   = vz[iyp+ixp+iz];
  917.    C C Vr2--> 			}
  918.    C C------> 		}
  919.    C--------> 	}
  920.               
  921.               	/* copy halo areas at bottom side */
  922.  + C--------< 	for (iy=0; iy<npy; iy++) {
  923.    C          		iyp=iy*nxz;
  924.  + C C------< 		for (ix=0; ix<npx; ix++) {
  925.    C C        			ixp=ix*npz;
  926.    C C        #pragma ivdep
  927.    C C Vr2--< 			for (iz=npz-2*halo; iz<npz-halo; iz++) {
  928.    C C Vr2    				ih=(iz-(npz-2*halo));
  929.    C C Vr2    				bottomSend[iy*npx*halo+ix*halo+ih]             = vx[iyp+ixp+iz];
  930.    C C Vr2    				bottomSend[halosizez+iy*npx*halo+ix*halo+ih]   = vz[iyp+ixp+iz];
  931.    C C Vr2--> 			}
  932.    C C------> 		}
  933.    C--------> 	}
  934.               
  935.               	return 0;
  936.               }
  937.               
  938.               int copyHaloP(float *p, int npx, int npy, int npz, int halo, float *leftSend, float *rightSend, float *frontSend, float *backSend, float *topSend, float *bottomSend)
  939.               {
  940.               	int ix, iy, iz, ih, iyp, ixp, halosizex, halosizey, halosizez, nxz;
  941.               
  942.               	nxz = npx*npz;
  943.               
  944.               	/* copy halo areas at left side */
  945.               	halosizex = npy*npz*halo;
  946.  + 1--------< 	for (iy=halo; iy<npy-halo; iy++) {
  947.    1          		iyp=iy*nxz;
  948.  + 1 2------< 		for (ix=halo; ix<2*halo; ix++) {
  949.    1 2        			ixp=ix*npz;
  950.    1 2        			ih=(ix-halo)*npz;
  951.    1 2        #pragma ivdep
  952.    1 2 Vr2--< 			for (iz=halo; iz<npz-halo; iz++) {
  953.    1 2 Vr2    				leftSend[iy*npz*halo+ih+iz]             = p[iyp+ixp+iz];
  954.    1 2 Vr2--> 			}
  955.    1 2------> 		}
  956.    1--------> 	}
  957.               
  958.               	/* copy halo areas at right side */
  959.               	halosizex = npy*npz*halo;
  960.  + 1--------< 	for (iy=halo; iy<npy-halo; iy++) {
  961.    1          		iyp=iy*nxz;
  962.  + 1 2------< 		for (ix=npx-2*halo; ix<npx-halo; ix++) {
  963.    1 2        			ixp=ix*npz;
  964.    1 2        			ih=(ix-(npx-2*halo))*npz;
  965.    1 2        #pragma ivdep
  966.    1 2 Vr2--< 			for (iz=halo; iz<npz-halo; iz++) {
  967.    1 2 Vr2    				rightSend[iy*npz*halo+ih+iz]             = p[iyp+ixp+iz];
  968.    1 2 Vr2--> 			}
  969.    1 2------> 		}
  970.    1--------> 	}
  971.               
  972.               
  973.               	/* copy halo areas at front side */
  974.               	halosizey = npx*npz*halo;
  975.  + C--------< 	for (iy=halo; iy<2*halo; iy++) {
  976.    C          		iyp=iy*nxz;
  977.    C          		ih=(iy-halo)*nxz;
  978.  + C C------< 		for (ix=0; ix<npx; ix++) {
  979.    C C        			ixp=ix*npz;
  980.    C C        #pragma ivdep
  981.    C C Vr2--< 			for (iz=halo; iz<npz-halo; iz++) {
  982.    C C Vr2    				frontSend[ih+ixp+iz]             = p[iyp+ixp+iz];
  983.    C C Vr2--> 			}
  984.    C C------> 		}
  985.    C--------> 	}
  986.               
  987.               	/* copy halo areas at back side */
  988.  + C--------< 	for (iy=npy-2*halo; iy<npy-halo; iy++) {
  989.    C          		iyp=iy*nxz;
  990.    C          		ih=(iy-(npy-2*halo))*nxz;
  991.  + C C------< 		for (ix=0; ix<npx; ix++) {
  992.    C C        			ixp=ix*npz;
  993.    C C        #pragma ivdep
  994.    C C Vr2--< 			for (iz=halo; iz<npz-halo; iz++) {
  995.    C C Vr2    				backSend[ih+ixp+iz]             = p[iyp+ixp+iz];
  996.    C C Vr2--> 			}
  997.    C C------> 		}
  998.    C--------> 	}
  999.               
 1000.               	/* copy halo areas at top side */
 1001.               	halosizez = npy*npx*halo;
 1002.  + C--------< 	for (iy=0; iy<npy; iy++) {
 1003.    C          		iyp=iy*nxz;
 1004.  + C C------< 		for (ix=0; ix<npx; ix++) {
 1005.    C C        			ixp=ix*npz;
 1006.    C C        #pragma ivdep
 1007.    C C Vr2--< 			for (iz=halo; iz<2*halo; iz++) {
 1008.    C C Vr2    				ih=iz-halo;
 1009.    C C Vr2    				topSend[iy*npx*halo+ix*halo+ih]             = p[iyp+ixp+iz];
 1010.    C C Vr2--> 			}
 1011.    C C------> 		}
 1012.    C--------> 	}
 1013.               
 1014.               	/* copy halo areas at bottom side */
 1015.  + C--------< 	for (iy=0; iy<npy; iy++) {
 1016.    C          		iyp=iy*nxz;
 1017.  + C C------< 		for (ix=0; ix<npx; ix++) {
 1018.    C C        			ixp=ix*npz;
 1019.    C C        #pragma ivdep
 1020.    C C Vr2--< 			for (iz=npz-2*halo; iz<npz-halo; iz++) {
 1021.    C C Vr2    				ih=(iz-(npz-2*halo));
 1022.    C C Vr2    				bottomSend[iy*npx*halo+ix*halo+ih]             = p[iyp+ixp+iz];
 1023.    C C Vr2--> 			}
 1024.    C C------> 		}
 1025.    C--------> 	}
 1026.               
 1027.               	return 0;
 1028.               }
 1029.               
 1030.               /* copy communicated halo areas back to compute grids */
 1031.               int newHaloVxVz(float *vx, float *vz, int npx, int npy, int npz, int halo, float *leftRecv, float *rightRecv, float *frontRecv, float *backRecv, float *topRecv, float *bottomRecv)
 1032.               {
 1033.               	int ix, iy, iz, ih, iyp, ixp, halosizex, halosizey, halosizez, nxz;
 1034.               
 1035.               	nxz = npx*npz;
 1036.               
 1037.               	/* copy halo areas at left side */
 1038.               	halosizex = npy*npz*halo;
 1039.  + 1--------< 	for (iy=halo; iy<npy-halo; iy++) {
 1040.    1          		iyp=iy*nxz;
 1041.  + 1 2------< 		for (ix=0; ix<halo; ix++) {
 1042.    1 2        			ixp=ix*npz;
 1043.    1 2        			ih=ixp;
 1044.    1 2        #pragma ivdep
 1045.    1 2 Vr2--< 			for (iz=halo; iz<npz-halo; iz++) {
 1046.    1 2 Vr2    				vx[iyp+ixp+iz] = leftRecv[iy*npz*halo+ih+iz];
 1047.    1 2 Vr2    				vz[iyp+ixp+iz] = leftRecv[halosizex+iy*npz*halo+ih+iz];
 1048.    1 2 Vr2--> 			}
 1049.    1 2------> 		}
 1050.    1--------> 	}
 1051.               
 1052.               	/* copy halo areas at right side */
 1053.               	halosizex = npy*npz*halo;
 1054.  + 1--------< 	for (iy=halo; iy<npy-halo; iy++) {
 1055.    1          		iyp=iy*nxz;
 1056.  + 1 2------< 		for (ix=npx-halo; ix<npx; ix++) {
 1057.    1 2        			ixp=ix*npz;
 1058.    1 2        			ih=(ix-(npx-halo))*npz;
 1059.    1 2        #pragma ivdep
 1060.    1 2 Vr2--< 			for (iz=halo; iz<npz-halo; iz++) {
 1061.    1 2 Vr2    				vx[iyp+ixp+iz] = rightRecv[iy*npz*halo+ih+iz];
 1062.    1 2 Vr2    				vz[iyp+ixp+iz] = rightRecv[halosizex+iy*npz*halo+ih+iz];
 1063.    1 2 Vr2--> 			}
 1064.    1 2------> 		}
 1065.    1--------> 	}
 1066.               
 1067.               
 1068.               	/* copy halo areas at front side */
 1069.               	halosizey = npx*npz*halo;
 1070.  + C--------< 	for (iy=0; iy<halo; iy++) {
 1071.    C          		iyp=iy*nxz;
 1072.    C          		ih=iyp;
 1073.  + C C------< 		for (ix=0; ix<npx; ix++) {
 1074.    C C        			ixp=ix*npz;
 1075.    C C        #pragma ivdep
 1076.    C C Vr2--< 			for (iz=halo; iz<npz-halo; iz++) {
 1077.    C C Vr2    				vx[iyp+ixp+iz] = frontRecv[ih+ixp+iz];
 1078.    C C Vr2    				vz[iyp+ixp+iz] = frontRecv[halosizey+ih+ixp+iz];
 1079.    C C Vr2--> 			}
 1080.    C C------> 		}
 1081.    C--------> 	}
 1082.               
 1083.               	/* copy halo areas at back side */
 1084.  + C--------< 	for (iy=npy-halo; iy<npy; iy++) {
 1085.    C          		iyp=iy*nxz;
 1086.    C          		ih=(iy-(npy-halo))*nxz;
 1087.  + C C------< 		for (ix=0; ix<npx; ix++) {
 1088.    C C        			ixp=ix*npz;
 1089.    C C        #pragma ivdep
 1090.    C C Vr2--< 			for (iz=halo; iz<npz-halo; iz++) {
 1091.    C C Vr2    				vx[iyp+ixp+iz] = backRecv[ih+ixp+iz];
 1092.    C C Vr2    				vz[iyp+ixp+iz] = backRecv[halosizey+ih+ixp+iz];
 1093.    C C Vr2--> 			}
 1094.    C C------> 		}
 1095.    C--------> 	}
 1096.               
 1097.               	/* copy halo areas at top side */
 1098.               	halosizez = npy*npx*halo;
 1099.  + C--------< 	for (iy=0; iy<npy; iy++) {
 1100.    C          		iyp=iy*nxz;
 1101.  + C C------< 		for (ix=0; ix<npx; ix++) {
 1102.    C C        			ixp=ix*npz;
 1103.    C C        #pragma ivdep
 1104.    C C Vr2--< 			for (iz=0; iz<halo; iz++) {
 1105.    C C Vr2    				ih=iz;
 1106.    C C Vr2    				vx[iyp+ixp+iz] = topRecv[iy*npx*halo+ix*halo+ih];
 1107.    C C Vr2    				vz[iyp+ixp+iz] = topRecv[halosizez+iy*npx*halo+ix*halo+ih];
 1108.    C C Vr2--> 			}
 1109.    C C------> 		}
 1110.    C--------> 	}
 1111.               
 1112.               	/* copy halo areas at bottom side */
 1113.  + C--------< 	for (iy=0; iy<npy; iy++) {
 1114.    C          		iyp=iy*nxz;
 1115.  + C C------< 		for (ix=0; ix<npx; ix++) {
 1116.    C C        			ixp=ix*npz;
 1117.    C C        #pragma ivdep
 1118.    C C Vr2--< 			for (iz=npz-halo; iz<npz; iz++) {
 1119.    C C Vr2    				ih=(iz-(npz-halo));
 1120.    C C Vr2    				vx[iyp+ixp+iz] = bottomRecv[iy*npx*halo+ix*halo+ih];
 1121.    C C Vr2    				vz[iyp+ixp+iz] = bottomRecv[halosizez+iy*npx*halo+ix*halo+ih];
 1122.    C C Vr2--> 			}
 1123.    C C------> 		}
 1124.    C--------> 	}
 1125.               
 1126.               	return 0;
 1127.               }
 1128.               
 1129.               /* copy communicated halo areas back to compute grids */
 1130.               int newHaloP(float *p, int npx, int npy, int npz, int halo, float *leftRecv, float *rightRecv, float *frontRecv, float *backRecv, float *topRecv, float *bottomRecv)
 1131.               {
 1132.               	int ix, iy, iz, ih, iyp, ixp, halosizex, halosizey, halosizez, nxz;
 1133.               
 1134.               	nxz = npx*npz;
 1135.               
 1136.               	/* copy halo areas at left side */
 1137.               	halosizex = npy*npz*halo;
 1138.  + 1--------< 	for (iy=halo; iy<npy-halo; iy++) {
 1139.    1          		iyp=iy*nxz;
 1140.  + 1 2------< 		for (ix=0; ix<halo; ix++) {
 1141.    1 2        			ixp=ix*npz;
 1142.    1 2        			ih=ixp;
 1143.    1 2        #pragma ivdep
 1144.    1 2 Vr2--< 			for (iz=halo; iz<npz-halo; iz++) {
 1145.    1 2 Vr2    				p[iyp+ixp+iz] = leftRecv[iy*npz*halo+ih+iz];
 1146.    1 2 Vr2--> 			}
 1147.    1 2------> 		}
 1148.    1--------> 	}
 1149.               
 1150.               	/* copy halo areas at right side */
 1151.               	halosizex = npy*npz*halo;
 1152.  + 1--------< 	for (iy=halo; iy<npy-halo; iy++) {
 1153.    1          		iyp=iy*nxz;
 1154.  + 1 2------< 		for (ix=npx-halo; ix<npx; ix++) {
 1155.    1 2        			ixp=ix*npz;
 1156.    1 2        			ih=(ix-(npx-halo))*npz;
 1157.    1 2        #pragma ivdep
 1158.    1 2 Vr2--< 			for (iz=halo; iz<npz-halo; iz++) {
 1159.    1 2 Vr2    				p[iyp+ixp+iz] = rightRecv[iy*npz*halo+ih+iz];
 1160.    1 2 Vr2--> 			}
 1161.    1 2------> 		}
 1162.    1--------> 	}
 1163.               
 1164.               
 1165.               	/* copy halo areas at front side */
 1166.               	halosizey = npx*npz*halo;
 1167.  + C--------< 	for (iy=0; iy<halo; iy++) {
 1168.    C          		iyp=iy*nxz;
 1169.    C          		ih=iyp;
 1170.  + C C------< 		for (ix=0; ix<npx; ix++) {
 1171.    C C        			ixp=ix*npz;
 1172.    C C        #pragma ivdep
 1173.    C C Vr2--< 			for (iz=halo; iz<npz-halo; iz++) {
 1174.    C C Vr2    				p[iyp+ixp+iz] = frontRecv[ih+ixp+iz];
 1175.    C C Vr2--> 			}
 1176.    C C------> 		}
 1177.    C--------> 	}
 1178.               
 1179.               	/* copy halo areas at back side */
 1180.  + C--------< 	for (iy=npy-halo; iy<npy; iy++) {
 1181.    C          		iyp=iy*nxz;
 1182.    C          		ih=(iy-(npy-halo))*nxz;
 1183.  + C C------< 		for (ix=0; ix<npx; ix++) {
 1184.    C C        			ixp=ix*npz;
 1185.    C C        #pragma ivdep
 1186.    C C Vr2--< 			for (iz=halo; iz<npz-halo; iz++) {
 1187.    C C Vr2    				p[iyp+ixp+iz] = backRecv[ih+ixp+iz];
 1188.    C C Vr2--> 			}
 1189.    C C------> 		}
 1190.    C--------> 	}
 1191.               
 1192.               	/* copy halo areas at top side */
 1193.               	halosizez = npy*npx*halo;
 1194.  + C--------< 	for (iy=0; iy<npy; iy++) {
 1195.    C          		iyp=iy*nxz;
 1196.  + C C------< 		for (ix=0; ix<npx; ix++) {
 1197.    C C        			ixp=ix*npz;
 1198.    C C        #pragma ivdep
 1199.    C C Vr2--< 			for (iz=0; iz<halo; iz++) {
 1200.    C C Vr2    				ih=iz;
 1201.    C C Vr2    				p[iyp+ixp+iz] = topRecv[iy*npx*halo+ix*halo+ih];
 1202.    C C Vr2--> 			}
 1203.    C C------> 		}
 1204.    C--------> 	}
 1205.               
 1206.               	/* copy halo areas at bottom side */
 1207.  + C--------< 	for (iy=0; iy<npy; iy++) {
 1208.    C          		iyp=iy*nxz;
 1209.  + C C------< 		for (ix=0; ix<npx; ix++) {
 1210.    C C        			ixp=ix*npz;
 1211.    C C        #pragma ivdep
 1212.    C C Vr2--< 			for (iz=npz-halo; iz<npz; iz++) {
 1213.    C C Vr2    				ih=(iz-(npz-halo));
 1214.    C C Vr2    				p[iyp+ixp+iz] = bottomRecv[iy*npx*halo+ix*halo+ih];
 1215.    C C Vr2--> 			}
 1216.    C C------> 		}
 1217.    C--------> 	}
 1218.               
 1219.               	return 0;
 1220.               }
 1221.               float gauss2time(float t, float f, float t0)
 1222.               {
 1223.                   float value, time;
 1224.               
 1225.               	time = t-t0;
 1226.                   value = ((1.0-2.0*M_PI*M_PI*f*f*time*time)*exp(-M_PI*M_PI*f*f*time*time));
 1227.                   return value;
 1228.               }
 1229.               

CC-3021 CC: IPA File = 3dfd.c, Line = 140 
  "MPI_Init" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 141 
  "MPI_Comm_rank" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 142 
  "MPI_Comm_size" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 143 
  "vinit" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 145 
  "wallclock_time" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 146 
  "initargs" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 147 
  "requestdoc" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 149 
  "getparint" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 150 
  "getParameters" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 156 
  "MPI_Dims_create" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 202 
  "fflush" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 215 
  A loop was unrolled 2 times.

CC-6213 CC: VECTOR File = 3dfd.c, Line = 215 
  A loop was conditionally vectorized.

CC-3021 CC: IPA File = 3dfd.c, Line = 225 
  "MPI_Cart_create" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 228 
  "MPI_Cart_coords" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 233 
  "fflush" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 237 
  "MPI_Cart_shift" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 238 
  "MPI_Cart_shift" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 239 
  "MPI_Cart_shift" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 241 
  "fflush" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 275 
  "MPI_Type_create_subarray" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 277 
  "MPI_Type_commit" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 289 
  "MPI_Type_create_subarray" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 291 
  "MPI_Type_commit" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 304 
  "wallclock_time" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 305 
  A loop was unrolled 4 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 305 
  A loop was vectorized.

CC-3182 CC: IPA File = 3dfd.c, Line = 305 
  Loop has been flattened.

CC-6009 CC: SCALAR File = 3dfd.c, Line = 307 
  A floating point expression involving an induction variable was strength reduced by optimization.  This may cause numerical
  differences.

CC-3001 CC: IPA File = 3dfd.c, Line = 307 
  The call to leaf routine "gauss2time" was textually inlined.

CC-3021 CC: IPA File = 3dfd.c, Line = 311 
  "fopen" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 312 
  "fwrite" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 313 
  "fflush" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 314 
  "fclose" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-6287 CC: VECTOR File = 3dfd.c, Line = 350 
  A loop was not vectorized because it contains a call to function "wallclock_time" on line 351.

CC-3021 CC: IPA File = 3dfd.c, Line = 351 
  "wallclock_time" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-6009 CC: SCALAR File = 3dfd.c, Line = 352 
  A floating point expression involving an induction variable was strength reduced by optimization.  This may cause numerical
  differences.

CC-3172 CC: IPA File = 3dfd.c, Line = 356 
  "gauss2time" (called from "main") was not inlined because the enclosing loop body did not completely flatten.

CC-3172 CC: IPA File = 3dfd.c, Line = 359 
  "updateVelocitiesHalo" (called from "main") was not inlined because the enclosing loop body did not completely flatten.

CC-3021 CC: IPA File = 3dfd.c, Line = 360 
  "wallclock_time" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3172 CC: IPA File = 3dfd.c, Line = 364 
  "copyHaloVxVz" (called from "main") was not inlined because the enclosing loop body did not completely flatten.

CC-3021 CC: IPA File = 3dfd.c, Line = 365 
  "wallclock_time" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3118 CC: IPA File = 3dfd.c, Line = 370 
  "exchangeHalo" (called from "main") was not inlined because the call site will not flatten.  "__assert_fail" is missing.

CC-3118 CC: IPA File = 3dfd.c, Line = 371 
  "exchangeHalo" (called from "main") was not inlined because the call site will not flatten.  "__assert_fail" is missing.

CC-3118 CC: IPA File = 3dfd.c, Line = 372 
  "exchangeHalo" (called from "main") was not inlined because the call site will not flatten.  "__assert_fail" is missing.

CC-3021 CC: IPA File = 3dfd.c, Line = 373 
  "wallclock_time" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3172 CC: IPA File = 3dfd.c, Line = 377 
  "updateVelocities" (called from "main") was not inlined because the enclosing loop body did not completely flatten.

CC-3021 CC: IPA File = 3dfd.c, Line = 378 
  "wallclock_time" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3118 CC: IPA File = 3dfd.c, Line = 382 
  "waitForHalo" (called from "main") was not inlined because the call site will not flatten.  "__assert_fail" is missing.

CC-3021 CC: IPA File = 3dfd.c, Line = 383 
  "wallclock_time" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3172 CC: IPA File = 3dfd.c, Line = 387 
  "newHaloVxVz" (called from "main") was not inlined because the enclosing loop body did not completely flatten.

CC-3021 CC: IPA File = 3dfd.c, Line = 388 
  "wallclock_time" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3172 CC: IPA File = 3dfd.c, Line = 409 
  "updatePressureHalo" (called from "main") was not inlined because the enclosing loop body did not completely flatten.

CC-3021 CC: IPA File = 3dfd.c, Line = 410 
  "wallclock_time" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3172 CC: IPA File = 3dfd.c, Line = 414 
  "copyHaloP" (called from "main") was not inlined because the enclosing loop body did not completely flatten.

CC-3118 CC: IPA File = 3dfd.c, Line = 415 
  "exchangeHalo" (called from "main") was not inlined because the call site will not flatten.  "__assert_fail" is missing.

CC-3118 CC: IPA File = 3dfd.c, Line = 416 
  "exchangeHalo" (called from "main") was not inlined because the call site will not flatten.  "__assert_fail" is missing.

CC-3118 CC: IPA File = 3dfd.c, Line = 417 
  "exchangeHalo" (called from "main") was not inlined because the call site will not flatten.  "__assert_fail" is missing.

CC-3021 CC: IPA File = 3dfd.c, Line = 418 
  "wallclock_time" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3172 CC: IPA File = 3dfd.c, Line = 422 
  "updatePressure" (called from "main") was not inlined because the enclosing loop body did not completely flatten.

CC-3021 CC: IPA File = 3dfd.c, Line = 423 
  "wallclock_time" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3118 CC: IPA File = 3dfd.c, Line = 427 
  "waitForHalo" (called from "main") was not inlined because the call site will not flatten.  "__assert_fail" is missing.

CC-3021 CC: IPA File = 3dfd.c, Line = 428 
  "wallclock_time" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3172 CC: IPA File = 3dfd.c, Line = 431 
  "newHaloP" (called from "main") was not inlined because the enclosing loop body did not completely flatten.

CC-3021 CC: IPA File = 3dfd.c, Line = 432 
  "wallclock_time" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 442 
  "wallclock_time" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 443 
  "sprintf" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 445 
  "MPI_Info_create" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 446 
  "MPI_Info_set" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 447 
  "MPI_Info_set" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 448 
  "MPI_File_delete" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 449 
  "MPI_File_open" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 452 
  "MPI_Abort" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 455 
  "MPI_File_set_view" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 458 
  "MPI_Abort" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 460 
  "MPI_File_write_all" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 462 
  "MPI_Error_string" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 464 
  "MPI_Abort" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 466 
  "MPI_File_close" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 477 
  "wallclock_time" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 482 
  "wallclock_time" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 495 
  "MPI_Finalize" (called from "main") was not inlined because the compiler was unable to locate the routine.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 518 
  A loop was not vectorized because a better candidate was found at line 523.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 520 
  A loop was not vectorized because a better candidate was found at line 523.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 523 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 523 
  A loop was vectorized.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 551 
  A loop was not vectorized because a better candidate was found at line 556.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 553 
  A loop was not vectorized because a better candidate was found at line 556.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 556 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 556 
  A loop was vectorized.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 569 
  A loop was not vectorized because a better candidate was found at line 574.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 571 
  A loop was not vectorized because a better candidate was found at line 574.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 574 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 574 
  A loop was vectorized.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 588 
  A loop was not vectorized because a better candidate was found at line 593.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 590 
  A loop was not vectorized because a better candidate was found at line 593.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 593 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 593 
  A loop was vectorized.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 606 
  A loop was not vectorized because a better candidate was found at line 611.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 608 
  A loop was not vectorized because a better candidate was found at line 611.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 611 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 611 
  A loop was vectorized.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 624 
  A loop was not vectorized because a better candidate was found at line 629.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 626 
  A loop was not vectorized because a better candidate was found at line 629.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 629 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 629 
  A loop was vectorized.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 642 
  A loop was not vectorized because a better candidate was found at line 647.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 644 
  A loop was not vectorized because a better candidate was found at line 647.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 647 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 647 
  A loop was vectorized.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 678 
  A loop was not vectorized because a better candidate was found at line 683.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 680 
  A loop was not vectorized because a better candidate was found at line 683.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 683 
  A loop was vectorized.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 704 
  A loop was not vectorized because a better candidate was found at line 709.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 706 
  A loop was not vectorized because a better candidate was found at line 709.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 709 
  A loop was vectorized.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 716 
  A loop was not vectorized because a better candidate was found at line 721.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 718 
  A loop was not vectorized because a better candidate was found at line 721.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 721 
  A loop was vectorized.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 729 
  A loop was not vectorized because a better candidate was found at line 734.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 731 
  A loop was not vectorized because a better candidate was found at line 734.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 734 
  A loop was vectorized.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 741 
  A loop was not vectorized because a better candidate was found at line 746.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 743 
  A loop was not vectorized because a better candidate was found at line 746.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 746 
  A loop was vectorized.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 753 
  A loop was not vectorized because a better candidate was found at line 758.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 755 
  A loop was not vectorized because a better candidate was found at line 758.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 758 
  A loop was vectorized.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 765 
  A loop was not vectorized because a better candidate was found at line 770.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 767 
  A loop was not vectorized because a better candidate was found at line 770.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 770 
  A loop was vectorized.

CC-3021 CC: IPA File = 3dfd.c, Line = 784 
  "MPI_Comm_rank" (called from "exchangeHalo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 788 
  "MPI_Irecv" (called from "exchangeHalo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 789 
  "__assert_fail" (called from "exchangeHalo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 792 
  "MPI_Isend" (called from "exchangeHalo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 793 
  "__assert_fail" (called from "exchangeHalo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 803 
  "MPI_Irecv" (called from "exchangeHalo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 805 
  "__assert_fail" (called from "exchangeHalo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 807 
  "MPI_Isend" (called from "exchangeHalo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 808 
  "__assert_fail" (called from "exchangeHalo") was not inlined because the compiler was unable to locate the routine.

CC-6287 CC: VECTOR File = 3dfd.c, Line = 825 
  A loop was not vectorized because it contains a call to function "MPI_Wait" on line 826.

CC-3021 CC: IPA File = 3dfd.c, Line = 826 
  "MPI_Wait" (called from "waitForHalo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 827 
  "__assert_fail" (called from "waitForHalo") was not inlined because the compiler was unable to locate the routine.

CC-6287 CC: VECTOR File = 3dfd.c, Line = 832 
  A loop was not vectorized because it contains a call to function "MPI_Wait" on line 833.

CC-3021 CC: IPA File = 3dfd.c, Line = 833 
  "MPI_Wait" (called from "waitForHalo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = 3dfd.c, Line = 834 
  "__assert_fail" (called from "waitForHalo") was not inlined because the compiler was unable to locate the routine.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 848 
  A loop was not vectorized because a better candidate was found at line 854.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 850 
  A loop was not vectorized because a better candidate was found at line 854.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 854 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 854 
  A loop was vectorized.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 863 
  A loop was not vectorized because a better candidate was found at line 869.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 865 
  A loop was not vectorized because a better candidate was found at line 869.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 869 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 869 
  A loop was vectorized.

CC-6296 CC: VECTOR File = 3dfd.c, Line = 879 
  A loop was not vectorized because it contains an inner loop where a "#pragma _CRI ivdep" or "concurrent" directive was specified.

CC-6003 CC: SCALAR File = 3dfd.c, Line = 879 
  A loop was collapsed into the loop starting at line 882.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 882 
  A loop was not vectorized because a better candidate was found at line 885.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 885 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 885 
  A loop was vectorized.

CC-6296 CC: VECTOR File = 3dfd.c, Line = 893 
  A loop was not vectorized because it contains an inner loop where a "#pragma _CRI ivdep" or "concurrent" directive was specified.

CC-6003 CC: SCALAR File = 3dfd.c, Line = 893 
  A loop was collapsed into the loop starting at line 896.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 896 
  A loop was not vectorized because a better candidate was found at line 899.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 899 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 899 
  A loop was vectorized.

CC-6296 CC: VECTOR File = 3dfd.c, Line = 908 
  A loop was not vectorized because it contains an inner loop where a "#pragma _CRI ivdep" or "concurrent" directive was specified.

CC-6003 CC: SCALAR File = 3dfd.c, Line = 908 
  A loop was collapsed into the loop starting at line 910.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 910 
  A loop was not vectorized because a better candidate was found at line 913.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 913 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 913 
  A loop was vectorized.

CC-6296 CC: VECTOR File = 3dfd.c, Line = 922 
  A loop was not vectorized because it contains an inner loop where a "#pragma _CRI ivdep" or "concurrent" directive was specified.

CC-6003 CC: SCALAR File = 3dfd.c, Line = 922 
  A loop was collapsed into the loop starting at line 924.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 924 
  A loop was not vectorized because a better candidate was found at line 927.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 927 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 927 
  A loop was vectorized.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 946 
  A loop was not vectorized because a better candidate was found at line 952.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 948 
  A loop was not vectorized because a better candidate was found at line 952.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 952 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 952 
  A loop was vectorized.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 960 
  A loop was not vectorized because a better candidate was found at line 966.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 962 
  A loop was not vectorized because a better candidate was found at line 966.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 966 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 966 
  A loop was vectorized.

CC-6296 CC: VECTOR File = 3dfd.c, Line = 975 
  A loop was not vectorized because it contains an inner loop where a "#pragma _CRI ivdep" or "concurrent" directive was specified.

CC-6003 CC: SCALAR File = 3dfd.c, Line = 975 
  A loop was collapsed into the loop starting at line 978.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 978 
  A loop was not vectorized because a better candidate was found at line 981.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 981 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 981 
  A loop was vectorized.

CC-6296 CC: VECTOR File = 3dfd.c, Line = 988 
  A loop was not vectorized because it contains an inner loop where a "#pragma _CRI ivdep" or "concurrent" directive was specified.

CC-6003 CC: SCALAR File = 3dfd.c, Line = 988 
  A loop was collapsed into the loop starting at line 991.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 991 
  A loop was not vectorized because a better candidate was found at line 994.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 994 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 994 
  A loop was vectorized.

CC-6296 CC: VECTOR File = 3dfd.c, Line = 1002 
  A loop was not vectorized because it contains an inner loop where a "#pragma _CRI ivdep" or "concurrent" directive was specified.

CC-6003 CC: SCALAR File = 3dfd.c, Line = 1002 
  A loop was collapsed into the loop starting at line 1004.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 1004 
  A loop was not vectorized because a better candidate was found at line 1007.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 1007 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 1007 
  A loop was vectorized.

CC-6296 CC: VECTOR File = 3dfd.c, Line = 1015 
  A loop was not vectorized because it contains an inner loop where a "#pragma _CRI ivdep" or "concurrent" directive was specified.

CC-6003 CC: SCALAR File = 3dfd.c, Line = 1015 
  A loop was collapsed into the loop starting at line 1017.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 1017 
  A loop was not vectorized because a better candidate was found at line 1020.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 1020 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 1020 
  A loop was vectorized.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 1039 
  A loop was not vectorized because a better candidate was found at line 1045.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 1041 
  A loop was not vectorized because a better candidate was found at line 1045.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 1045 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 1045 
  A loop was vectorized.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 1054 
  A loop was not vectorized because a better candidate was found at line 1060.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 1056 
  A loop was not vectorized because a better candidate was found at line 1060.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 1060 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 1060 
  A loop was vectorized.

CC-6296 CC: VECTOR File = 3dfd.c, Line = 1070 
  A loop was not vectorized because it contains an inner loop where a "#pragma _CRI ivdep" or "concurrent" directive was specified.

CC-6003 CC: SCALAR File = 3dfd.c, Line = 1070 
  A loop was collapsed into the loop starting at line 1073.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 1073 
  A loop was not vectorized because a better candidate was found at line 1076.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 1076 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 1076 
  A loop was vectorized.

CC-6296 CC: VECTOR File = 3dfd.c, Line = 1084 
  A loop was not vectorized because it contains an inner loop where a "#pragma _CRI ivdep" or "concurrent" directive was specified.

CC-6003 CC: SCALAR File = 3dfd.c, Line = 1084 
  A loop was collapsed into the loop starting at line 1087.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 1087 
  A loop was not vectorized because a better candidate was found at line 1090.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 1090 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 1090 
  A loop was vectorized.

CC-6296 CC: VECTOR File = 3dfd.c, Line = 1099 
  A loop was not vectorized because it contains an inner loop where a "#pragma _CRI ivdep" or "concurrent" directive was specified.

CC-6003 CC: SCALAR File = 3dfd.c, Line = 1099 
  A loop was collapsed into the loop starting at line 1101.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 1101 
  A loop was not vectorized because a better candidate was found at line 1104.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 1104 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 1104 
  A loop was vectorized.

CC-6296 CC: VECTOR File = 3dfd.c, Line = 1113 
  A loop was not vectorized because it contains an inner loop where a "#pragma _CRI ivdep" or "concurrent" directive was specified.

CC-6003 CC: SCALAR File = 3dfd.c, Line = 1113 
  A loop was collapsed into the loop starting at line 1115.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 1115 
  A loop was not vectorized because a better candidate was found at line 1118.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 1118 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 1118 
  A loop was vectorized.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 1138 
  A loop was not vectorized because a better candidate was found at line 1144.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 1140 
  A loop was not vectorized because a better candidate was found at line 1144.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 1144 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 1144 
  A loop was vectorized.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 1152 
  A loop was not vectorized because a better candidate was found at line 1158.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 1154 
  A loop was not vectorized because a better candidate was found at line 1158.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 1158 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 1158 
  A loop was vectorized.

CC-6296 CC: VECTOR File = 3dfd.c, Line = 1167 
  A loop was not vectorized because it contains an inner loop where a "#pragma _CRI ivdep" or "concurrent" directive was specified.

CC-6003 CC: SCALAR File = 3dfd.c, Line = 1167 
  A loop was collapsed into the loop starting at line 1170.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 1170 
  A loop was not vectorized because a better candidate was found at line 1173.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 1173 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 1173 
  A loop was vectorized.

CC-6296 CC: VECTOR File = 3dfd.c, Line = 1180 
  A loop was not vectorized because it contains an inner loop where a "#pragma _CRI ivdep" or "concurrent" directive was specified.

CC-6003 CC: SCALAR File = 3dfd.c, Line = 1180 
  A loop was collapsed into the loop starting at line 1183.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 1183 
  A loop was not vectorized because a better candidate was found at line 1186.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 1186 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 1186 
  A loop was vectorized.

CC-6296 CC: VECTOR File = 3dfd.c, Line = 1194 
  A loop was not vectorized because it contains an inner loop where a "#pragma _CRI ivdep" or "concurrent" directive was specified.

CC-6003 CC: SCALAR File = 3dfd.c, Line = 1194 
  A loop was collapsed into the loop starting at line 1196.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 1196 
  A loop was not vectorized because a better candidate was found at line 1199.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 1199 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 1199 
  A loop was vectorized.

CC-6296 CC: VECTOR File = 3dfd.c, Line = 1207 
  A loop was not vectorized because it contains an inner loop where a "#pragma _CRI ivdep" or "concurrent" directive was specified.

CC-6003 CC: SCALAR File = 3dfd.c, Line = 1207 
  A loop was collapsed into the loop starting at line 1209.

CC-6294 CC: VECTOR File = 3dfd.c, Line = 1209 
  A loop was not vectorized because a better candidate was found at line 1212.

CC-6005 CC: SCALAR File = 3dfd.c, Line = 1212 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = 3dfd.c, Line = 1212 
  A loop was vectorized.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
