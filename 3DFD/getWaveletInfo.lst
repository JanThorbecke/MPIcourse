%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          S u m m a r y   R e p o r t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Compilation
-----------
File     : /cray/css/u19/jan/src/3DFD/getWaveletInfo.c
Compiled : 2015-09-11  08:11:50
Compiler : Version 8.4.0.223
Ftnlx    : Version 8412 (libcif 84005)
Target   : x86-64
Command  : driver.cc -h cpu=haswell -h dynamic -D __CRAYCS -D __CRAY_HASWELL
           -D __CRAYXT_COMPUTE_LINUX_TARGET -O 3 -h fp3 -h noomp -h list=a -I .
           -c getWaveletInfo.c
           -W l,--rpath=/opt/cray/cce/8.4.0.223/craylibs/x86-64
           -ibase-compiler /opt/cray/cce/8.4.0.223/CC/x86-64/compiler_include_ba
           se -isystem /opt/cray/cce/8.4.0.223/craylibs/x86-64/include
           -isystem /usr/local/cuda/include
           -I /opt/gcc/4.8.1/snos/lib/gcc/x86_64-suse-linux/4.8.1/include
           -I /opt/gcc/4.8.1/snos/lib/gcc/x86_64-suse-linux/4.8.1/include-fixed
           -I /opt/cray/mvapich2_slurm/2.0.1.4/CRAY/8.4/include
           -I /opt/cray/libsci/13.2.0.1/CRAY/8.3/x86_64/include
           -I /global/opt/nvidia/cudatoolkit/7.0.28/include
           -I /opt/cray/cce/8.4.0.223/craylibs/x86-64/include

clx report
------------
Source   : /cray/css/u19/jan/src/3DFD/getWaveletInfo.c
Date     : 09/11/2015  08:11:50


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          O p t i o n s   R e p o r t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Options :  -h cache2,fp3,scalar3,thread2,vector3,mpi0,ipa3,noaggress         
           -h autoprefetch,noautothread,fusion2,nomsgs,nonegmsgs         
           -h nooverindex,pattern,unroll2,nozeroinc         
           -h noadd_paren,noupc,dwarf,nofp_trap,nofunc_trace         
           -h noomp_analyze,noomp_trace,nopat_trace         
           -h noomp,noomp_acc,noacc         
           -h c99,noexceptions,nostrict,noinfinitevl         
           -h notolerant,gnu         
           -h flex_mp=default         
           -h cpu=x86-64,haswell
           -h network=gemini         
           -K trap=none 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          S o u r c e   L i s t i n g
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


     %%%    L o o p m a r k   L e g e n d    %%%

     Primary Loop Type        Modifiers
     ------- ---- ----        ---------
     A - Pattern matched      a - atomic memory operation
                              b - blocked
     C - Collapsed            c - conditional and/or computed
     D - Deleted               
     E - Cloned                
     F - Flat - No calls      f - fused
     G - Accelerated          g - partitioned
     I - Inlined              i - interchanged
     M - Multithreaded        m - partitioned
                              n - non-blocking remote transfer
                              p - partial
                              r - unrolled
                              s - shortloop
     V - Vectorized           w - unwound

     + - More messages listed at end of listing
     ------------------------------------------


    1.             #define _FILE_OFFSET_BITS 64
    2.             #define _LARGEFILE_SOURCE
    3.             #define _LARGEFILE64_SOURCE
    4.             
    5.             #include <assert.h>
    6.             #include <stdio.h>
    7.             #include <stdlib.h>
    8.             #include <errno.h>
    9.             #include <math.h>
   10.             #include "segy.h"
   11.             
   12.             /**
   13.             *  reads file which contain the source wavelets and computes sampling interval
   14.             *  and tries to estimate the maximum frequency content.
   15.             *
   16.             *   AUTHOR:
   17.             *           Jan Thorbecke (janth@xs4all.nl)
   18.             *           The Netherlands 
   19.             **/
   20.             
   21.             #ifndef COMPLEX
   22.             typedef struct _complexStruct { /* complex number */
   23.                 float r,i;
   24.             } complex;
   25.             typedef struct _dcomplexStruct { /* complex number */
   26.                 double r,i;
   27.             } dcomplex;
   28.             #endif/* complex */
   29.             
   30.             int optncr(int n);
   31.             void rc1fft(float *rdata, complex *cdata, int n, int sign);
   32.             
   33.             #define     MAX(x,y) ((x) > (y) ? (x) : (y))
   34.             #define     MIN(x,y) ((x) < (y) ? (x) : (y))
   35.             #define NINT(x) ((int)((x)>0.0?(x)+0.5:(x)-0.5))
   36.             
   37.             int getWaveletInfo(char *file_src, int *n1, int *n2, float *d1, float *d2, float *f1, float *f2, float *fmax, int *nxm, int verbose)
   38.             {
   39.                 FILE    *fp;
   40.                 size_t  nread, data_sz;
   41.             	off_t bytes, ret, trace_sz, ntraces;
   42.                 int sx_shot, gx_start, one_shot;
   43.                 int optn, nfreq, i, iwmax;
   44.                 float *trace;
   45.             	float ampl, amplmax, tampl, tamplmax; 
   46.                 complex *ctrace;
   47.                 segy hdr;
   48.                 
   49.                 if (file_src == NULL) return 0; /* Input pipe can not be handled */
   50.  +              else fp = fopen( file_src, "r" );
   51.  +              assert( fp != NULL);
   52.  +              nread = fread( &hdr, 1, TRCBYTES, fp );
   53.  +              assert(nread == TRCBYTES);
   54.  +              ret = fseeko( fp, 0, SEEK_END );
   55.  +          	if (ret<0) perror("fseeko");
   56.  +              bytes = ftello( fp );
   57.             
   58.                 *n1 = hdr.ns;
   59.                 if (hdr.trid == 1 || hdr.dt != 0) {
   60.                     *d1 = ((float) hdr.dt)*1.e-6;
   61.                     *f1 = ((float) hdr.delrt)/1000.;
   62.             		if (*d1 == 0.0) *d1 = hdr.d1;
   63.                 }
   64.                 else {
   65.                     *d1 = hdr.d1;
   66.                     *f1 = hdr.f1;
   67.                 }
   68.                 *f2 = hdr.f2;
   69.             
   70.                 data_sz = sizeof(float)*(*n1);
   71.                 trace_sz = sizeof(float)*(*n1)+TRCBYTES;
   72.                 ntraces  = (int) (bytes/trace_sz);
   73.             	*n2 = ntraces;
   74.             
   75.                 /* check to find out number of traces in shot gather */
   76.             
   77.  +          	optn = optncr(hdr.ns);
   78.             	nfreq = optn/2 + 1;
   79.             	ctrace = (complex *)malloc(nfreq*sizeof(complex));
   80.                 one_shot = 1;
   81.                 sx_shot  = hdr.sx;
   82.                 gx_start = hdr.gx;
   83.                 trace = (float *)malloc(optn*sizeof(float));
   84.  +              fseeko( fp, TRCBYTES, SEEK_SET );
   85.             
   86.  + 1------<     while (one_shot) {
   87.    1        		memset(trace,0,optn*sizeof(float));
   88.  + 1                nread = fread( trace, sizeof(float), hdr.ns, fp );
   89.  + 1                assert (nread == hdr.ns);
   90.    1        		tamplmax = 0.0;
   91.    1 Vr6--< 		for (i=0;i<hdr.ns;i++) {
   92.    1 Vr6    			tampl = fabsf(trace[i]);
   93.    1 Vr6    			if (tampl > tamplmax) tamplmax = tampl;
   94.    1 Vr6--> 		}
   95.    1        		if (trace[0]*1e-3 > tamplmax) {
   96.    1        			fprintf(stderr,"WARNING: file_src has a large amplitude %f at t=0\n", trace[0]);
   97.    1        			fprintf(stderr,"This will introduce high frequencies and can cause dispersion.\n");
   98.    1        		}
   99.    1        
  100.    1        		/* estimate maximum frequency assuming amplitude spectrum is smooth */
  101.  + 1        		rc1fft(trace,ctrace,optn,1);
  102.    1        
  103.    1        		/* find maximum amplitude */
  104.    1        		amplmax = 0.0;
  105.  + 1 2----< 		for (i=0;i<nfreq;i++) {
  106.    1 2      			ampl = sqrt(ctrace[i].r*ctrace[i].r+ctrace[i].i*ctrace[i].i);
  107.    1 2      			if (ampl > amplmax) {
  108.    1 2      				amplmax = ampl;
  109.    1 2      				iwmax = i;
  110.    1 2      			}
  111.    1 2----> 		}
  112.    1        		/* from the maximum amplitude position look for the largest frequency
  113.    1                 * which has an amplitude 400 times weaker than the maximum amplitude */
  114.  + 1 2----< 		for (i=iwmax;i<nfreq;i++) {
  115.    1 2      			ampl = sqrt(ctrace[i].r*ctrace[i].r+ctrace[i].i*ctrace[i].i);
  116.    1 2      			if (400*ampl < amplmax) {
  117.    1 2      				*fmax = (i-1)*(1.0/(optn*(*d1)));
  118.    1 2      				break;
  119.    1 2      			}
  120.    1 2----> 		}
  121.    1        
  122.  + 1                nread = fread( &hdr, 1, TRCBYTES, fp );
  123.    1                if (nread==0) break;
  124.    1------>     }
  125.             	*nxm = (int)ntraces;
  126.             
  127.             	if (verbose>2) {
  128.  +          		vmess("For file %s", file_src);
  129.  +          		vmess("nt=%d nx=%d", *n1, *n2);
  130.  +          		vmess("dt=%f dx=%f", *d1, *d2);
  131.  +          		vmess("fmax=%f", *fmax);
  132.  +          		vmess("tstart=%f", *f1);
  133.             	}
  134.             
  135.  +              fclose(fp);
  136.                 free(trace);
  137.                 free(ctrace);
  138.             
  139.                 return 0;
  140.             }

CC-3021 CC: IPA File = getWaveletInfo.c, Line = 50 
  "fopen" (called from "getWaveletInfo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getWaveletInfo.c, Line = 51 
  "__assert_fail" (called from "getWaveletInfo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getWaveletInfo.c, Line = 52 
  "fread" (called from "getWaveletInfo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getWaveletInfo.c, Line = 53 
  "__assert_fail" (called from "getWaveletInfo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getWaveletInfo.c, Line = 54 
  "fseeko" (called from "getWaveletInfo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getWaveletInfo.c, Line = 55 
  "perror" (called from "getWaveletInfo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getWaveletInfo.c, Line = 56 
  "ftello" (called from "getWaveletInfo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getWaveletInfo.c, Line = 77 
  "optncr" (called from "getWaveletInfo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getWaveletInfo.c, Line = 84 
  "fseeko" (called from "getWaveletInfo") was not inlined because the compiler was unable to locate the routine.

CC-6263 CC: VECTOR File = getWaveletInfo.c, Line = 86 
  A loop was not vectorized because it contains a reference to a non-vector intrinsic on line 87.

CC-3021 CC: IPA File = getWaveletInfo.c, Line = 88 
  "fread" (called from "getWaveletInfo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getWaveletInfo.c, Line = 89 
  "__assert_fail" (called from "getWaveletInfo") was not inlined because the compiler was unable to locate the routine.

CC-6005 CC: SCALAR File = getWaveletInfo.c, Line = 91 
  A loop was unrolled 6 times.

CC-6204 CC: VECTOR File = getWaveletInfo.c, Line = 91 
  A loop was vectorized.

CC-3021 CC: IPA File = getWaveletInfo.c, Line = 101 
  "rc1fft" (called from "getWaveletInfo") was not inlined because the compiler was unable to locate the routine.

CC-6337 CC: VECTOR File = getWaveletInfo.c, Line = 105 
  A loop was not vectorized because it contains unsupported conditional constructs near line 108.

CC-6334 CC: VECTOR File = getWaveletInfo.c, Line = 114 
  A loop was not vectorized because it contains multiple potential exits.

CC-3021 CC: IPA File = getWaveletInfo.c, Line = 122 
  "fread" (called from "getWaveletInfo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getWaveletInfo.c, Line = 128 
  "vmess" (called from "getWaveletInfo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getWaveletInfo.c, Line = 129 
  "vmess" (called from "getWaveletInfo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getWaveletInfo.c, Line = 130 
  "vmess" (called from "getWaveletInfo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getWaveletInfo.c, Line = 131 
  "vmess" (called from "getWaveletInfo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getWaveletInfo.c, Line = 132 
  "vmess" (called from "getWaveletInfo") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getWaveletInfo.c, Line = 135 
  "fclose" (called from "getWaveletInfo") was not inlined because the compiler was unable to locate the routine.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
