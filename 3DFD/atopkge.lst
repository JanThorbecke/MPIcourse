%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          S u m m a r y   R e p o r t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Compilation
-----------
File     : /cray/css/u19/jan/src/3DFD/atopkge.c
Compiled : 2015-09-11  08:11:51
Compiler : Version 8.4.0.223
Ftnlx    : Version 8412 (libcif 84005)
Target   : x86-64
Command  : driver.cc -h cpu=haswell -h dynamic -D __CRAYCS -D __CRAY_HASWELL
           -D __CRAYXT_COMPUTE_LINUX_TARGET -O 3 -h fp3 -h noomp -h list=a -I .
           -c atopkge.c -W l,--rpath=/opt/cray/cce/8.4.0.223/craylibs/x86-64
           -ibase-compiler /opt/cray/cce/8.4.0.223/CC/x86-64/compiler_include_ba
           se -isystem /opt/cray/cce/8.4.0.223/craylibs/x86-64/include
           -isystem /usr/local/cuda/include
           -I /opt/gcc/4.8.1/snos/lib/gcc/x86_64-suse-linux/4.8.1/include
           -I /opt/gcc/4.8.1/snos/lib/gcc/x86_64-suse-linux/4.8.1/include-fixed
           -I /opt/cray/mvapich2_slurm/2.0.1.4/CRAY/8.4/include
           -I /opt/cray/libsci/13.2.0.1/CRAY/8.3/x86_64/include
           -I /global/opt/nvidia/cudatoolkit/7.0.28/include
           -I /opt/cray/cce/8.4.0.223/craylibs/x86-64/include

clx report
------------
Source   : /cray/css/u19/jan/src/3DFD/atopkge.c
Date     : 09/11/2015  08:11:52


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          O p t i o n s   R e p o r t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Options :  -h cache2,fp3,scalar3,thread2,vector3,mpi0,ipa3,noaggress         
           -h autoprefetch,noautothread,fusion2,nomsgs,nonegmsgs         
           -h nooverindex,pattern,unroll2,nozeroinc         
           -h noadd_paren,noupc,dwarf,nofp_trap,nofunc_trace         
           -h noomp_analyze,noomp_trace,nopat_trace         
           -h noomp,noomp_acc,noacc         
           -h c99,noexceptions,nostrict,noinfinitevl         
           -h notolerant,gnu         
           -h flex_mp=default         
           -h cpu=x86-64,haswell
           -h network=gemini         
           -K trap=none 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          S o u r c e   L i s t i n g
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


     %%%    L o o p m a r k   L e g e n d    %%%

     Primary Loop Type        Modifiers
     ------- ---- ----        ---------
     A - Pattern matched      a - atomic memory operation
                              b - blocked
     C - Collapsed            c - conditional and/or computed
     D - Deleted               
     E - Cloned                
     F - Flat - No calls      f - fused
     G - Accelerated          g - partitioned
     I - Inlined              i - interchanged
     M - Multithreaded        m - partitioned
                              n - non-blocking remote transfer
                              p - partial
                              r - unrolled
                              s - shortloop
     V - Vectorized           w - unwound

     + - More messages listed at end of listing
     ------------------------------------------


    1.     /*                        
    2.      
    3.      This file is property of the Colorado School of Mines.
    4.      
    5.      Copyright (C) 2007, Colorado School of Mines,
    6.      All rights reserved.
    7.      
    8.      
    9.      Redistribution and use in source and binary forms, with or 
   10.      without modification, are permitted provided that the following 
   11.      conditions are met:
   12.      
   13.      *  Redistributions of source code must retain the above copyright 
   14.      notice, this list of conditions and the following disclaimer.
   15.      *  Redistributions in binary form must reproduce the above 
   16.      copyright notice, this list of conditions and the following 
   17.      disclaimer in the documentation and/or other materials provided 
   18.      with the distribution.
   19.      *  Neither the name of the Colorado School of Mines nor the names of
   20.      its contributors may be used to endorse or promote products 
   21.      derived from this software without specific prior written permission.
   22.      
   23.      Warranty Disclaimer:
   24.      THIS SOFTWARE IS PROVIDED BY THE COLORADO SCHOOL OF MINES AND CONTRIBUTORS 
   25.      "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
   26.      LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
   27.      FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE 
   28.      COLORADO SCHOOL OF MINES OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
   29.      INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
   30.      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
   31.      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
   32.      CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
   33.      STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
   34.      IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
   35.      POSSIBILITY OF SUCH DAMAGE.
   36.      
   37.      
   38.      Export Restriction Disclaimer:
   39.      We believe that CWP/SU: Seismic Un*x is a low technology product that does
   40.      not appear on the Department of Commerce CCL list of restricted exports.
   41.      Accordingly, we believe that our product meets the qualifications of
   42.      an ECCN (export control classification number) of EAR99 and we believe
   43.      it fits the qualifications of NRR (no restrictions required), and
   44.      is thus not subject to export restrictions of any variety.
   45.      
   46.      Approved Reference Format:
   47.      In publications, please refer to SU as per the following example:
   48.      Cohen, J. K. and Stockwell, Jr. J. W., (200_), CWP/SU: Seismic Un*x 
   49.      Release No. __: an open source software  package for seismic 
   50.      research and processing, 
   51.      Center for Wave Phenomena, Colorado School of Mines.
   52.      
   53.      Articles about SU in peer-reviewed journals:
   54.      Saeki, T., (1999), A guide to Seismic Un*x (SU)(2)---examples of data processing (part 1), data input and preparation of headers, Butsuri-Tansa (Geophysical Exploration), vol. 52, no. 5, 465-477.
   55.      Stockwell, Jr. J. W. (1999), The CWP/SU: Seismic Un*x Package, Computers and Geosciences, May 1999.
   56.      Stockwell, Jr. J. W. (1997), Free Software in Education: A case study of CWP/SU: Seismic Un*x, The Leading Edge, July 1997.
   57.      Templeton, M. E., Gough, C.A., (1998), Web Seismic Un*x: Making seismic reflection processing more accessible, Computers and Geosciences.
   58.      
   59.      Acknowledgements:
   60.      SU stands for CWP/SU:Seismic Un*x, a processing line developed at Colorado 
   61.      School of Mines, partially based on Stanford Exploration Project (SEP) 
   62.      software.
   63.      */
   64.     
   65.     /*********************** self documentation **********************/
   66.     /***************************************************************************
   67.     ATOPKGE - convert ascii to arithmetic and with error checking
   68.     
   69.      
   70.     eatoh		ascii to short
   71.     eatou		ascii to unsigned short
   72.     eatoi		ascii to int
   73.     eatop		ascii to unsigned
   74.     eatol		ascii to long
   75.     eatov		ascii to unsigned long
   76.     eatof		ascii to float
   77.     eatod		ascii to double
   78.     
   79.     ****************************************************************************
   80.     Function Prototypes:
   81.     short eatoh(char *s);
   82.     unsigned short eatou(char *s);
   83.     int eatoi(char *s);
   84.     unsigned int eatop(char *s);
   85.     long eatol(char *s);
   86.     unsigned long eatov(char *s);
   87.     float eatof(char *s);
   88.     double eatod(char *s);
   89.     
   90.     ****************************************************************************
   91.     Input:
   92.     s		string 
   93.     
   94.     Returned:	type indicated
   95.      
   96.     ****************************************************************************
   97.     Notes:
   98.     Each of these routines acts like atoi, but has error checking:
   99.     
  100.     This is a major revision of the tedious code required before
  101.     vendors implemented the ANSI C strtol, strtoul and strtod.
  102.     
  103.     In addition to the size checks for each integer type, a
  104.     specific test on errno is required.  For example, INT_MAX
  105.     may (and probably does) equal LONG_MAX.  In this case,
  106.     if fed a number exceeding INT_MAX (and LONG_MAX), strtol
  107.     will make a quiet return with the wrong answer and it is up
  108.     to the user to check if errno == ERANGE.
  109.     
  110.     Size limits are machine dependent and are read from the
  111.     ANSI C include files limits.h and float.h.
  112.     
  113.     Bug Report: With NeXT c and Gnucc, when x > DBL_MAX (x <-DBL_MAX),
  114.     the return value from strtod was +Infinity (-Infinity), not HUGE_VAL
  115.     and more important, errno was not set to ERANGE.  To cope with this,
  116.     I put explicit size checks in eatod (which would not be needed if
  117.     errno were set as it should be in ANSI C.    jkc 01/29/94
  118.     
  119.     On IBM RS6000, the return value from strtod was +-Inf on
  120.     overflow, but errno was set correctly.
  121.     
  122.     ****************************************************************************
  123.     References:
  124.     For old code:
  125.     Plum: Reliable Data Structures in C, p. 2-17.
  126.     Kernighan and Ritchie: The C Programming Language, p. 58.
  127.     
  128.     CWP: Jack K. Cohen, Brian Sumner
  129.      
  130.     For new code:
  131.     ANSI C routines with a little help from Jack
  132.     
  133.     ****************************************************************************
  134.     Author: Jack Cohen, Center for Wave Phenomena, 1994.
  135.     ***************************************************************************/
  136.     /**************** end self doc ********************************/
  137.     
  138.     #include "par.h"
  139.     #include <float.h>
  140.     #include <limits.h>
  141.     #include <stdarg.h>
  142.     #include <errno.h>
  143.     
  144.     /* eatoh - convert string s to short integer {SHRT_MIN:SHRT_MAX} */
  145.     short eatoh(char *s)
  146.     {
  147.  +  	long n = strtol(s, NULL, 10);
  148.     	
  149.     	if ( (n > SHRT_MAX) || (n < SHRT_MIN) || (errno == ERANGE) )
  150.  +  		err("%s: eatoh: overflow", __FILE__);
  151.     
  152.     	return (short) n;
  153.     }
  154.     
  155.     
  156.     /* eatou - convert string s to unsigned short integer {0:USHRT_MAX} */
  157.     unsigned short eatou(char *s)
  158.     {
  159.  +  	unsigned long n = strtoul(s, NULL, 10);
  160.     
  161.     	if ( (n > USHRT_MAX) || (errno == ERANGE) )
  162.  +  		err("%s: eatou: overflow", __FILE__);
  163.     
  164.     	return (unsigned short) n;
  165.     }
  166.     
  167.     
  168.     /* eatoi - convert string s to integer {INT_MIN:INT_MAX} */
  169.     int eatoi(char *s)
  170.     {
  171.  +  	long n = strtol(s, NULL, 10);
  172.     
  173.     	if ( (n > INT_MAX) || (n < INT_MIN) || (errno == ERANGE) )
  174.  +  		err("%s: eatoi: overflow", __FILE__);
  175.     
  176.     	return (int) n;
  177.     }
  178.     
  179.     
  180.     /* eatop - convert string s to unsigned integer {0:UINT_MAX} */
  181.     unsigned int eatop(char *s)
  182.     {
  183.  +  	unsigned long n = strtoul(s, NULL, 10);
  184.     
  185.     	if ( (n > UINT_MAX) || (errno == ERANGE) )
  186.  +  		err("%s: eatop: overflow", __FILE__);
  187.     
  188.     	return (unsigned int) n;
  189.     }
  190.     
  191.     
  192.     /* eatol - convert string s to long integer {LONG_MIN:LONG_MAX} */
  193.     long eatol(char *s)
  194.     {
  195.  +  	long n = strtol(s, NULL, 10);
  196.     
  197.     	if (errno == ERANGE)
  198.  +  		err("%s: eatol: overflow", __FILE__);
  199.     
  200.     	return n;
  201.     }
  202.     
  203.     
  204.     /* eatov - convert string s to unsigned long {0:ULONG_MAX} */
  205.     unsigned long eatov(char *s)
  206.     {
  207.  +  	unsigned long n = strtoul(s, NULL, 10);
  208.     
  209.     	if (errno == ERANGE)
  210.  +  		err("%s: eatov: overflow", __FILE__);
  211.     
  212.     	return n;
  213.     }
  214.     
  215.     
  216.     /* eatof - convert string s to float {-FLT_MAX:FLT_MAX} */
  217.     float eatof(char *s)
  218.     {
  219.  +  	float x = strtod(s, NULL);
  220.     
  221.     	if ( (x > FLT_MAX) || (x < -FLT_MAX) || (errno == ERANGE) )
  222.  +  		err("%s: eatof: overflow", __FILE__);
  223.     
  224.     	return (float) x;
  225.     }
  226.     
  227.     
  228.     /* eatod - convert string s to double {-DBL_MAX:DBL_MAX} */
  229.     double eatod(char *s)
  230.     {
  231.  +  	double x = strtod(s, NULL);
  232.     
  233.     	/* errno == ERANGE suffices if compiler sets errno on overflow */
  234.     	if ( (errno == ERANGE) || (x > DBL_MAX) || (x < -DBL_MAX) )
  235.  +  		err("%s: eatod: overflow", __FILE__);
  236.     
  237.     	return x;
  238.     }
  239.     
  240.     
  241.     /**************************************************************************
  242.     ERRPKGE - routines for reporting errors
  243.     
  244.     err	print warning on application program error and die
  245.     warn	print warning on application program error
  246.     syserr	print warning on application program error using errno and die
  247.     
  248.     ***************************************************************************
  249.     Function Prototypes:
  250.     void err (char *fmt, ...);
  251.     void warn (char *fmt, ...);
  252.     void syserr (char *fmt, ...);
  253.     
  254.     ***************************************************************************
  255.     Return: void
  256.     
  257.     ***************************************************************************
  258.     Notes:
  259.     fmt		a printf format string ("\n" not needed)
  260.     ...		the variables referenced in the format string
  261.     
  262.     Examples:
  263.     	err("Cannot divide %f by %f", x, y);
  264.     	warn("fmax = %f exceeds half nyquist= %f", fmax, 0.25/dt);
  265.      
  266.     	if (NULL == (fp = fopen(xargv[1], "r")))
  267.      		err("can't open %s", xargv[1]);
  268.      	...
  269.      	if (-1 == close(fd))
  270.      		err("close failed");
  271.     
  272.     ***************************************************************************
  273.     References:
  274.     Kernighan and Pike, "The UNIX Programming Environment", page 207.
  275.     Also Rochkind, "Advanced UNIX Programming", page 13.
  276.     
  277.     ***************************************************************************
  278.     Authors:SEP: Jeff Thorson, Stew Levin	CWP: Shuki Ronen, Jack Cohen
  279.     **************************************************************************/
  280.     
  281.     
  282.     void err(char *fmt, ...)
  283.     {
  284.     	va_list args;
  285.     
  286.      
  287.  +  	if (EOF == fflush(stdout)) {
  288.     		fprintf(stderr, "\nerr: fflush failed on stdout");
  289.     	}
  290.     	fprintf(stderr, "\n%s: ", xargv[0]);
  291.     	va_start(args,fmt);
  292.  +  	vfprintf(stderr, fmt, args);
  293.     	va_end(args);
  294.     	fprintf(stderr, "\n");
  295.  +  	exit(EXIT_FAILURE);
  296.     }
  297.     
  298.     
  299.     void warn(char *fmt, ...)
  300.     {
  301.     	va_list args;
  302.     
  303.  +  	if (EOF == fflush(stdout)) {
  304.     		fprintf(stderr, "\nwarn: fflush failed on stdout");
  305.     	}
  306.     	fprintf(stderr, "\n%s: ", xargv[0]);
  307.     	va_start(args,fmt);
  308.  +  	vfprintf(stderr, fmt, args);
  309.     	va_end(args);
  310.     	fprintf(stderr, "\n");
  311.     	return;
  312.     }
  313.     
  314.     
  315.     void syserr(char *fmt, ...)
  316.     {
  317.         va_list args;
  318.     
  319.  +      if (EOF == fflush(stdout)) {
  320.             fprintf(stderr, "\nsyserr: fflush failed on stdout");
  321.         }
  322.         fprintf(stderr, "\n%s: ", xargv[0]);
  323.         va_start(args,fmt);
  324.  +      vfprintf(stderr, fmt, args);
  325.         va_end(args);
  326.  +      fprintf(stderr, " (%s)\n", strerror(errno));
  327.  +      exit(EXIT_FAILURE);
  328.     }
  329.     
  330.     #ifdef TEST
  331.     main(int argc, char **argv)
  332.     {
  333.     	char s[BUFSIZ];
  334.     	short nh;
  335.     	unsigned short nu;
  336.     	int ni;
  337.     	unsigned int np;
  338.     	long nl;
  339.     	unsigned long nv;
  340.     
  341.     	initargs(argc, argv);
  342.     
  343.     
  344.     	/* Test code for eatoh */
  345.     	if (SHRT_MAX == LONG_MAX) {
  346.     	    warn("Warning: eatoh not used on this machine.\n");
  347.     	} else {
  348.     	    warn("\n");
  349.     	}
  350.     	strcpy(s, "0");
  351.     	nh = eatoh(s);
  352.     	warn("eatoh(%s) = %hd\n", s, nh);
  353.     
  354.     	strcpy(s, "32767");
  355.     	nh = eatoh(s);
  356.     	warn("eatoh(%s) = %hd\n", s, nh);
  357.     
  358.     	strcpy(s, "-32768");
  359.     	nh = eatoh(s);
  360.     	warn("eatoh(%s) = %hd\n", s, nh);
  361.     
  362.     
  363.     	/* Test code for eatou */
  364.     	if (USHRT_MAX == ULONG_MAX) {
  365.     	    warn("Warning: eatou not used on this machine.\n");
  366.     	} else {
  367.     	    warn("\n");
  368.     	}
  369.     	strcpy(s, "0");
  370.     	nu = eatou(s);
  371.     	warn("eatou(%s) = %hu\n", s, nu);
  372.     
  373.     	strcpy(s, "65535");
  374.     	nu = eatou(s);
  375.     	warn("eatou(%s) = %hu\n", s, nu);
  376.     
  377.     
  378.     	/* Test code for eatoi */
  379.     	if (INT_MAX == LONG_MAX) {
  380.     	    warn("Warning: eatoi not used on this machine.\n");
  381.     	} else {
  382.     	    warn("\n");
  383.     	}
  384.     	strcpy(s, "0");
  385.     	ni = eatoi(s);
  386.     	warn("eatoi(%s) = %d\n", s, ni);
  387.     
  388.     	strcpy(s, "2147483647");
  389.     	ni = eatoi(s);
  390.     	warn("eatoi(%s) = %d\n", s, ni);
  391.     
  392.     
  393.     	strcpy(s, "-2147483648");
  394.     	ni = eatoi(s);
  395.     	warn("eatoi(%s) = %d\n", s, ni);
  396.     
  397.     
  398.     	/* Test code for eatop */
  399.     	if (INT_MAX == LONG_MAX) {
  400.     	    warn("Warning: eatop not used on this machine.\n");
  401.     	} else {
  402.     	    warn("\n");
  403.     	}
  404.     	strcpy(s, "0");
  405.     	np = eatop(s);
  406.     	warn("eatop(%s) = %lu\n", s, np);
  407.     
  408.     	strcpy(s, "4294967295");
  409.     	np = eatop(s);
  410.     	warn("eatop(%s) = %lu\n", s, np);
  411.     
  412.     
  413.     	/* Test code for eatol */
  414.     	warn("\n");
  415.     	strcpy(s, "0");
  416.     	nl = eatol(s);
  417.     	warn("eatol(%s) = %ld\n", s, nl);
  418.     
  419.     	strcpy(s, "2147483647");
  420.     	nl = eatol(s);
  421.     	warn("eatol(%s) = %ld\n", s, nl);
  422.     
  423.     	strcpy(s, "-2147483648");
  424.     	nl = eatol(s);
  425.     	warn("eatol(%s) = %ld\n", s, nl);
  426.     
  427.     
  428.     	/* Test code for eatov */
  429.     	strcpy(s, "0");
  430.     	nv = eatov(s);
  431.     	warn("eatov(%s) = %lu\n", s, nv);
  432.     
  433.     	strcpy(s, "4294967295");
  434.     	nv = eatov(s);
  435.     	warn("eatov(%s) = %lu\n", s, nv);
  436.     
  437.     	warn("Now we feed in 4294967296, expecting fatal error exit\n");
  438.     	strcpy(s, "4294967296");
  439.     	nv = eatov(s);
  440.     	warn("eatov(%s) = %lu\n", s, nv);
  441.     
  442.     	return EXIT_SUCCESS;
  443.     }
  444.     #endif

CC-3021 CC: IPA File = atopkge.c, Line = 147 
  "strtol" (called from "eatoh") was not inlined because the compiler was unable to locate the routine.

CC-3162 CC: IPA File = atopkge.c, Line = 150 
  "err" (called from "eatoh") was not inlined because it has a variable number of formal parameters.

CC-3021 CC: IPA File = atopkge.c, Line = 159 
  "strtoul" (called from "eatou") was not inlined because the compiler was unable to locate the routine.

CC-3162 CC: IPA File = atopkge.c, Line = 162 
  "err" (called from "eatou") was not inlined because it has a variable number of formal parameters.

CC-3021 CC: IPA File = atopkge.c, Line = 171 
  "strtol" (called from "eatoi") was not inlined because the compiler was unable to locate the routine.

CC-3162 CC: IPA File = atopkge.c, Line = 174 
  "err" (called from "eatoi") was not inlined because it has a variable number of formal parameters.

CC-3021 CC: IPA File = atopkge.c, Line = 183 
  "strtoul" (called from "eatop") was not inlined because the compiler was unable to locate the routine.

CC-3162 CC: IPA File = atopkge.c, Line = 186 
  "err" (called from "eatop") was not inlined because it has a variable number of formal parameters.

CC-3021 CC: IPA File = atopkge.c, Line = 195 
  "strtol" (called from "eatol") was not inlined because the compiler was unable to locate the routine.

CC-3162 CC: IPA File = atopkge.c, Line = 198 
  "err" (called from "eatol") was not inlined because it has a variable number of formal parameters.

CC-3021 CC: IPA File = atopkge.c, Line = 207 
  "strtoul" (called from "eatov") was not inlined because the compiler was unable to locate the routine.

CC-3162 CC: IPA File = atopkge.c, Line = 210 
  "err" (called from "eatov") was not inlined because it has a variable number of formal parameters.

CC-3021 CC: IPA File = atopkge.c, Line = 219 
  "strtod" (called from "eatof") was not inlined because the compiler was unable to locate the routine.

CC-3162 CC: IPA File = atopkge.c, Line = 222 
  "err" (called from "eatof") was not inlined because it has a variable number of formal parameters.

CC-3021 CC: IPA File = atopkge.c, Line = 231 
  "strtod" (called from "eatod") was not inlined because the compiler was unable to locate the routine.

CC-3162 CC: IPA File = atopkge.c, Line = 235 
  "err" (called from "eatod") was not inlined because it has a variable number of formal parameters.

CC-3021 CC: IPA File = atopkge.c, Line = 287 
  "fflush" (called from "err") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = atopkge.c, Line = 292 
  "vfprintf" (called from "err") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = atopkge.c, Line = 295 
  "exit" (called from "err") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = atopkge.c, Line = 303 
  "fflush" (called from "warn") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = atopkge.c, Line = 308 
  "vfprintf" (called from "warn") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = atopkge.c, Line = 319 
  "fflush" (called from "syserr") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = atopkge.c, Line = 324 
  "vfprintf" (called from "syserr") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = atopkge.c, Line = 326 
  "strerror" (called from "syserr") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = atopkge.c, Line = 327 
  "exit" (called from "syserr") was not inlined because the compiler was unable to locate the routine.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
