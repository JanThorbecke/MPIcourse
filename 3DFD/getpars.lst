%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          S u m m a r y   R e p o r t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Compilation
-----------
File     : /cray/css/u19/jan/src/3DFD/getpars.c
Compiled : 2015-09-11  08:11:52
Compiler : Version 8.4.0.223
Ftnlx    : Version 8412 (libcif 84005)
Target   : x86-64
Command  : driver.cc -h cpu=haswell -h dynamic -D __CRAYCS -D __CRAY_HASWELL
           -D __CRAYXT_COMPUTE_LINUX_TARGET -O 3 -h fp3 -h noomp -h list=a -I .
           -c getpars.c -W l,--rpath=/opt/cray/cce/8.4.0.223/craylibs/x86-64
           -ibase-compiler /opt/cray/cce/8.4.0.223/CC/x86-64/compiler_include_ba
           se -isystem /opt/cray/cce/8.4.0.223/craylibs/x86-64/include
           -isystem /usr/local/cuda/include
           -I /opt/gcc/4.8.1/snos/lib/gcc/x86_64-suse-linux/4.8.1/include
           -I /opt/gcc/4.8.1/snos/lib/gcc/x86_64-suse-linux/4.8.1/include-fixed
           -I /opt/cray/mvapich2_slurm/2.0.1.4/CRAY/8.4/include
           -I /opt/cray/libsci/13.2.0.1/CRAY/8.3/x86_64/include
           -I /global/opt/nvidia/cudatoolkit/7.0.28/include
           -I /opt/cray/cce/8.4.0.223/craylibs/x86-64/include

clx report
------------
Source   : /cray/css/u19/jan/src/3DFD/getpars.c
Date     : 09/11/2015  08:11:52


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          O p t i o n s   R e p o r t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Options :  -h cache2,fp3,scalar3,thread2,vector3,mpi0,ipa3,noaggress         
           -h autoprefetch,noautothread,fusion2,nomsgs,nonegmsgs         
           -h nooverindex,pattern,unroll2,nozeroinc         
           -h noadd_paren,noupc,dwarf,nofp_trap,nofunc_trace         
           -h noomp_analyze,noomp_trace,nopat_trace         
           -h noomp,noomp_acc,noacc         
           -h c99,noexceptions,nostrict,noinfinitevl         
           -h notolerant,gnu         
           -h flex_mp=default         
           -h cpu=x86-64,haswell
           -h network=gemini         
           -K trap=none 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          S o u r c e   L i s t i n g
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


     %%%    L o o p m a r k   L e g e n d    %%%

     Primary Loop Type        Modifiers
     ------- ---- ----        ---------
     A - Pattern matched      a - atomic memory operation
                              b - blocked
     C - Collapsed            c - conditional and/or computed
     D - Deleted               
     E - Cloned                
     F - Flat - No calls      f - fused
     G - Accelerated          g - partitioned
     I - Inlined              i - interchanged
     M - Multithreaded        m - partitioned
                              n - non-blocking remote transfer
                              p - partial
                              r - unrolled
                              s - shortloop
     V - Vectorized           w - unwound

     + - More messages listed at end of listing
     ------------------------------------------


    1.           /* This file is property of the Colorado School of Mines.
    2.            
    3.            Copyright (C) 2007, Colorado School of Mines,
    4.            All rights reserved.
    5.            
    6.            
    7.            Redistribution and use in source and binary forms, with or 
    8.            without modification, are permitted provided that the following 
    9.            conditions are met:
   10.            
   11.            *  Redistributions of source code must retain the above copyright 
   12.            notice, this list of conditions and the following disclaimer.
   13.            *  Redistributions in binary form must reproduce the above 
   14.            copyright notice, this list of conditions and the following 
   15.            disclaimer in the documentation and/or other materials provided 
   16.            with the distribution.
   17.            *  Neither the name of the Colorado School of Mines nor the names of
   18.            its contributors may be used to endorse or promote products 
   19.            derived from this software without specific prior written permission.
   20.            
   21.            Warranty Disclaimer:
   22.            THIS SOFTWARE IS PROVIDED BY THE COLORADO SCHOOL OF MINES AND CONTRIBUTORS 
   23.            "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
   24.            LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
   25.            FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE 
   26.            COLORADO SCHOOL OF MINES OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
   27.            INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
   28.            BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
   29.            LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
   30.            CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
   31.            STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
   32.            IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
   33.            POSSIBILITY OF SUCH DAMAGE.
   34.            
   35.            
   36.            Export Restriction Disclaimer:
   37.            We believe that CWP/SU: Seismic Un*x is a low technology product that does
   38.            not appear on the Department of Commerce CCL list of restricted exports.
   39.            Accordingly, we believe that our product meets the qualifications of
   40.            an ECCN (export control classification number) of EAR99 and we believe
   41.            it fits the qualifications of NRR (no restrictions required), and
   42.            is thus not subject to export restrictions of any variety.
   43.            
   44.            Approved Reference Format:
   45.            In publications, please refer to SU as per the following example:
   46.            Cohen, J. K. and Stockwell, Jr. J. W., (200_), CWP/SU: Seismic Un*x 
   47.            Release No. __: an open source software  package for seismic 
   48.            research and processing, 
   49.            Center for Wave Phenomena, Colorado School of Mines.
   50.            
   51.            Articles about SU in peer-reviewed journals:
   52.            Saeki, T., (1999), A guide to Seismic Un*x (SU)(2)---examples of data processing (part 1), data input and preparation of headers, Butsuri-Tansa (Geophysical Exploration), vol. 52, no. 5, 465-477.
   53.            Stockwell, Jr. J. W. (1999), The CWP/SU: Seismic Un*x Package, Computers and Geosciences, May 1999.
   54.            Stockwell, Jr. J. W. (1997), Free Software in Education: A case study of CWP/SU: Seismic Un*x, The Leading Edge, July 1997.
   55.            Templeton, M. E., Gough, C.A., (1998), Web Seismic Un*x: Making seismic reflection processing more accessible, Computers and Geosciences.
   56.            
   57.            Acknowledgements:
   58.            SU stands for CWP/SU:Seismic Un*x, a processing line developed at Colorado 
   59.            School of Mines, partially based on Stanford Exploration Project (SEP) 
   60.            software.
   61.            */
   62.           
   63.           /*********************** self documentation **********************/
   64.           /*****************************************************************************
   65.           GETPARS - Functions to GET PARameterS from the command line. Numeric
   66.           	parameters may be single values or arrays of int, uint,
   67.           	short, ushort, long, ulong, float, or double.  Single character
   68.           	strings (type string or char *) may also be gotten. 
   69.           	Arrays of strings, delimited by, but not containing
   70.                   commas are permitted.
   71.           
   72.           The functions are:
   73.           
   74.           initargs 	Makes command line args available to subroutines (re-entrant).
   75.           		Every par program starts with this call!
   76.           getparint		get integers
   77.           getparuint		get unsigned integers
   78.           getparshort		get short integers
   79.           getparushort		get unsigned short integers
   80.           getparlong		get long integers 
   81.           getparulong		get unsigned long integers
   82.           getparfloat		get float
   83.           getpardouble		get double
   84.           getparstring		get a single string
   85.           getparstringarray	get string array (fields delimited by commas) 
   86.           getpar			get parameter by type
   87.           getnparint		get n'th occurrence of integer
   88.           getnparuint		get n'th occurrence of unsigned int
   89.           getnparshort		get n'th occurrence of short integer
   90.           getnparushort		get n'th occurrence of unsigned short int
   91.           getnparlong		get n'th occurrence of long integer
   92.           getnparulong		get n'th occurrence of unsigned long int
   93.           getnparfloat		get n'th occurrence of float integer
   94.           getnpardouble		get n'th occurrence of double integer
   95.           getnparstring		get n'th occurrence of string integer
   96.           getnparstringarray	get n'th occurrence of string integer array
   97.           getnpar			get n'th occurrence by type
   98.           countparname		return the number of times a parameter names is used
   99.           countparval		return the number of values in the last occurrence
  100.           				of a parameter
  101.           countnparval		return the number of values in the n'th occurrence
  102.           				of a parameter
  103.           getPar			Promax compatible version of getpar
  104.           
  105.           ******************************************************************************
  106.           Function Prototypes:
  107.           void initargs (int argc, char **argv);
  108.           int getparint (char *name, int *p);
  109.           int getparuint (char *name, unsigned int *p);
  110.           int getparshort (char *name, short *p);
  111.           int getparushort (char *name, unsigned short *p);
  112.           int getparlong (char *name, long *p);
  113.           int getparulong (char *name, unsigned long *p);
  114.           int getparfloat (char *name, float *p);
  115.           int getpardouble (char *name, double *p);
  116.           int getparstring (char *name, char **p);
  117.           int getparstringarray (char *name, char **p);
  118.           int getnparint (int n, char *name, int *p);
  119.           int getnparuint (int n, char *name, unsigned int *p);
  120.           int getnparshort (int n, char *name, short *p);
  121.           int getnparushort (int n, char *name, unsigned short *p);
  122.           int getnparlong (int n, char *name, long *p);
  123.           int getnparulong (int n, char *name, unsigned long *p);
  124.           int getnparfloat (int n, char *name, float *p);
  125.           int getnpardouble (int n, char *name, double *p);
  126.           int getnparstring (int n, char *name, char **p);
  127.           int getnparstringarray (int n, char *name, char **p);
  128.           int getnpar (int n, char *name, char *type, void *ptr);
  129.           int countparname (char *name);
  130.           int countparval (char *name);
  131.           int countnparval (int n, char *name);
  132.           void getPar(char *name, char *type, void *ptr);
  133.           
  134.           ******************************************************************************
  135.           Notes:
  136.           Here are some usage examples:
  137.           
  138.           	... if integer n not specified, then default to zero. 
  139.           	if (!getparint("n", &n)) n = 0;
  140.           	
  141.           	... if array of floats vx is specified, then
  142.           	if (nx=countparval("vx")) {
  143.           		... allocate space for array
  144.           		vx = (float *)malloc(nx*sizeof(float));
  145.           		... and get the floats
  146.           		getparfloat("vx",vx);
  147.           	}
  148.           	
  149.           The command line for the above examples might look like:
  150.           	progname n=35 vx=3.21,4,9.5
  151.           	Every par program starts with this call!
  152.           
  153.           More examples are provided in the DTEST code at the end of this file.
  154.           
  155.           The functions: eatoh, eatou, eatol, eatov, eatoi, eatop used
  156.           below are versions of atoi that check for overflow.  The source
  157.           file for these functions is atopkge.c.
  158.           
  159.           ******************************************************************************	
  160.           Authors:
  161.           Rob Clayton & Jon Claerbout, Stanford University, 1979-1985
  162.           Shuki Ronen & Jack Cohen, Colorado School of Mines, 1985-1990
  163.           Dave Hale, Colorado School of Mines, 05/29/90
  164.           Credit to John E. Anderson for re-entrant initargs 03/03/94
  165.           *****************************************************************************/	
  166.           /**************** end self doc ********************************/
  167.           
  168.           #include "par.h"
  169.           
  170.           #ifndef TRUE
  171.           #define TRUE (1)
  172.           #endif
  173.           #ifndef FALSE
  174.           #define FALSE (0)
  175.           #endif
  176.           
  177.           /* parameter table */
  178.           typedef struct {
  179.           	char *name;		/* external name of parameter	*/
  180.           	char *asciival;		/* ascii value of parameter	*/
  181.           } pointer_table;
  182.           
  183.           /* global variables declared and used internally */
  184.           static pointer_table *argtbl;	/* parameter table		*/
  185.           static int nargs;		/* number of args that parse	*/
  186.           static int tabled = FALSE;	/* true when parameters tabled 	*/
  187.           static int targc;		/* total number of args		*/
  188.           static char **targv;		/* pointer to arg strings	*/
  189.           static char *argstr;		/* storage for command line	*/
  190.           
  191.           /* functions declared and used internally */
  192.           static int getparindex (int n, char *name);
  193.           static void getparinit(void);
  194.           static void tabulate (int argc, char **argv);
  195.           static char *getpfname (void);
  196.           static int white2null (char *str, int len);
  197.           static int ccount (char c, char *s);
  198.           static void strchop(char *s, char *t);
  199.           
  200.           /* make command line args available to subroutines -- re-entrant version */
  201.           void initargs(int argc, char **argv)
  202.           {
  203.           	xargc = argc; xargv = argv;
  204.           	if(tabled==TRUE){
  205.           		free(argstr);
  206.           		free(targv);
  207.           		free(argtbl);
  208.           	}
  209.           	tabled =  FALSE;
  210.           	return;
  211.           }
  212.           
  213.           /* functions to get values for the last occurrence of a parameter name */
  214.           int getparint (char *name, int *ptr)
  215.           {
  216.  +        	return getnpar(0,name,"i",ptr);
  217.           }
  218.           int getparuint (char *name, unsigned int *ptr)
  219.           {
  220.  +        	return getnpar(0,name,"p",ptr);
  221.           }
  222.           int getparshort (char *name, short *ptr)
  223.           {
  224.  +        	return getnpar(0,name,"h",ptr);
  225.           }
  226.           int getparushort (char *name, unsigned short *ptr)
  227.           {
  228.  +        	return getnpar(0,name,"u",ptr);
  229.           }
  230.           int getparlong (char *name, long *ptr)
  231.           {
  232.  +        	return getnpar(0,name,"l",ptr);
  233.           }
  234.           int getparulong (char *name, unsigned long *ptr)
  235.           {
  236.  +        	return getnpar(0,name,"v",ptr);
  237.           }
  238.           int getparfloat (char *name, float *ptr)
  239.           {
  240.  +        	return getnpar(0,name,"f",ptr);
  241.           }
  242.           int getpardouble (char *name, double *ptr)
  243.           {
  244.  +        	return getnpar(0,name,"d",ptr);
  245.           }
  246.           int getparstring (char *name, char **ptr)
  247.           {
  248.  +        	return getnpar(0,name,"s",ptr);
  249.           }
  250.           int getparstringarray (char *name, char **ptr)
  251.           {
  252.  +        	return getnpar(0,name,"a",ptr);
  253.           }
  254.           int getpar (char *name, char *type, void *ptr)
  255.           {
  256.  +        	return getnpar(0,name,type,ptr);
  257.           }
  258.           
  259.           /* functions to get values for the n'th occurrence of a parameter name */
  260.           int getnparint (int n, char *name, int *ptr)
  261.           {
  262.  +        	return getnpar(n,name,"i",ptr);
  263.           }
  264.           int getnparuint (int n, char *name, unsigned int *ptr)
  265.           {
  266.  +        	return getnpar(n,name,"p",ptr);
  267.           }
  268.           int getnparshort (int n, char *name, short *ptr)
  269.           {
  270.  +        	return getnpar(n,name,"h",ptr);
  271.           }
  272.           int getnparushort (int n, char *name, unsigned short *ptr)
  273.           {
  274.  +        	return getnpar(n,name,"u",ptr);
  275.           }
  276.           int getnparlong (int n, char *name, long *ptr)
  277.           {
  278.  +        	return getnpar(n,name,"l",ptr);
  279.           }
  280.           int getnparulong (int n, char *name, unsigned long *ptr)
  281.           {
  282.  +        	return getnpar(n,name,"v",ptr);
  283.           }
  284.           int getnparfloat (int n, char *name, float *ptr)
  285.           {
  286.  +        	return getnpar(n,name,"f",ptr);
  287.           }
  288.           int getnpardouble (int n, char *name, double *ptr)
  289.           {
  290.  +        	return getnpar(n,name,"d",ptr);
  291.           }
  292.           int getnparstring (int n, char *name, char **ptr)
  293.           {
  294.  +        	return getnpar(n,name,"s",ptr);
  295.           }
  296.           int getnparstringarray (int n, char *name, char **ptr)
  297.           {
  298.  +        	return getnpar(n,name,"a",ptr);
  299.           }
  300.           int getnpar (int n, char *name, char *type, void *ptr)
  301.           {
  302.           	int i;			/* index of name in symbol table	*/
  303.           	int nval;		/* number of parameter values found	*/
  304.           	char *aval;		/* ascii field of symbol		*/
  305.           
  306.           	if (xargc == 1) return 0;
  307.  +        	if (!tabled) getparinit();/* Tabulate command line and parfile */
  308.  +        	i = getparindex(n,name);/* Get parameter index */
  309.           	if (i < 0) return 0;	/* Not there */
  310.           	
  311.           	/* 
  312.           	 * handle string type as a special case, since a string 
  313.           	 * may contain commas. 
  314.           	 */
  315.           	if (type[0]=='s') {
  316.           		*((char**)ptr) = argtbl[i].asciival;
  317.           		return 1;
  318.           	} 
  319.           
  320.           	/* convert vector of ascii values to numeric values */
  321.  + 1----< 	for (nval=0,aval=argtbl[i].asciival; *aval; nval++) {
  322.    1      		switch (type[0]) {
  323.    1      			case 'i':
  324.  + 1      				*(int*)ptr = eatoi(aval);
  325.    1      				ptr = (int*)ptr+1;
  326.    1      				break;
  327.    1      			case 'p':
  328.  + 1      				*(unsigned int*)ptr = eatop(aval);
  329.    1      				ptr = (unsigned int*)ptr+1;
  330.    1      				break;
  331.    1      			case 'h':
  332.  + 1      				*(short*)ptr = eatoh(aval);
  333.    1      				ptr = (short*)ptr+1;
  334.    1      				break;
  335.    1      			case 'u':
  336.  + 1      				*(unsigned short*)ptr = eatou(aval);
  337.    1      				ptr = (unsigned short*)ptr+1;
  338.    1      				break;
  339.    1      			case 'l':
  340.  + 1      				*(long*)ptr = eatol(aval);
  341.    1      				ptr = (long*)ptr+1;
  342.    1      				break;
  343.    1      			case 'v':
  344.  + 1      				*(unsigned long*)ptr = eatov(aval);
  345.    1      				ptr = (unsigned long*)ptr+1;
  346.    1      				break;
  347.    1      			case 'f':
  348.  + 1      				*(float*)ptr = eatof(aval);
  349.    1      				ptr = (float*)ptr+1;
  350.    1      				break;
  351.    1      			case 'd':
  352.  + 1      				*(double*)ptr = eatod(aval);
  353.    1      				ptr = (double*)ptr+1;
  354.    1      				break;
  355.    1      			case 'a':
  356.    1      				{ char *tmpstr="";
  357.    1      				   tmpstr = (char *)calloc(strlen(aval),1);
  358.    1      
  359.  + 1      				   strchop(aval,tmpstr);
  360.    1      				   *(char**)ptr = tmpstr;
  361.    1      				   ptr=(char **)ptr + 1;
  362.    1      				}
  363.    1      				   break;
  364.    1      			default:
  365.  + 1      				err("%s: invalid parameter type = %s",
  366.    1      					__FILE__,type);
  367.    1      		}
  368.  + 1 2--< 		while (*aval++ != ',') {
  369.    1 2    			if (!*aval) break;
  370.    1 2--> 		}
  371.    1----> 	}
  372.           	return nval;
  373.           }
  374.           /* Promax compatible version of getnpar */
  375.           void getPar(char *name, char *type, void *ptr)
  376.           {
  377.  +        	(void) getnpar(0,name,type,ptr);
  378.           	return;
  379.           }
  380.           
  381.           /* return number of occurrences of parameter name */
  382.           int countparname (char *name)
  383.           {
  384.           	int i,nname;
  385.           
  386.           	if (xargc == 1) return 0;
  387.  +        	if (!tabled) getparinit();
  388.  + F----< 	for (i=0,nname=0; i<nargs; ++i)
  389.    F----> 		if (!strcmp(name,argtbl[i].name)) ++nname;
  390.           	return nname;
  391.           }
  392.           
  393.           /* return number of values in n'th occurrence of parameter name */
  394.           int countnparval (int n, char *name)
  395.           {
  396.           	int i;
  397.           
  398.           	if (xargc == 1) return 0;
  399.  +        	if (!tabled) getparinit();
  400.  +        	i = getparindex(n,name);
  401.           	if (i>=0) 
  402.  +  I---> 		return ccount(',',argtbl[i].asciival) + 1;
  403.           	else
  404.           		return 0;
  405.           }
  406.           
  407.           /* return number of values in last occurrence of parameter name */
  408.           int countparval (char *name)
  409.           {
  410.  +        	return countnparval(0,name);
  411.           }
  412.           
  413.           
  414.           
  415.           /*
  416.            * Return the index of the n'th occurrence of a parameter name, 
  417.            * except if n==0, return the index of the last occurrence.
  418.            * Return -1 if the specified occurrence does not exist.
  419.            */
  420.           static int getparindex (int n, char *name)
  421.           {
  422.           	int i;
  423.           	if (n==0) {
  424.  + F----< 		for (i=nargs-1; i>=0; --i)
  425.    F----> 			if (!strcmp(name,argtbl[i].name)) break;
  426.           		return i;
  427.           	} else {
  428.  + F----< 		for (i=0; i<nargs; ++i)
  429.    F      			if (!strcmp(name,argtbl[i].name))
  430.    F----> 				if (--n==0) break;
  431.           		if (i<nargs)
  432.           			return i;
  433.           		else
  434.           			return -1;
  435.           	}
  436.           }
  437.           
  438.           /* Initialize getpar */
  439.           static void getparinit (void)
  440.           {
  441.           	static char *pfname;	/* name of parameter file		*/
  442.           	FILE *pffd=NULL;	/* file id of parameter file		*/
  443.           	int pflen;		/* length of parameter file in bytes	*/ 
  444.           	static int pfargc;	/* arg count from parameter file	*/
  445.           	int parfile;		/* parfile existence flag		*/
  446.           	int argstrlen;
  447.           	char *pargstr;		/* storage for parameter file args	*/
  448.           	int nread;		/* bytes fread				*/
  449.           	int i, j;		/* counters				*/
  450.           
  451.           
  452.           	tabled = TRUE;		/* remember table is built		*/
  453.           
  454.           	/* Check if xargc was initiated */
  455.           	if(!xargc)
  456.  +        		err("%s: xargc=%d -- not initiated in main", __FILE__, xargc);
  457.           
  458.           	/* Space needed for command lines */
  459.  + F----< 	for (i = 1, argstrlen = 0; i < xargc; i++) {
  460.    F      		argstrlen += strlen(xargv[i]) + 1;
  461.    F----> 	}
  462.           
  463.           	/* Get parfile name if there is one */
  464.           	/* parfile = (pfname = getpfname()) ? TRUE : FALSE; */
  465.  +  Ip--> 	if ((pfname = getpfname())) {
  466.           		parfile = TRUE;
  467.           	} else {
  468.           		parfile = FALSE;
  469.           	}
  470.           
  471.           	if (parfile) {
  472.  +        	 	pffd = fopen(pfname, "r");
  473.           
  474.           		/* Get the length */
  475.  +        		fseek(pffd, 0, SEEK_END);
  476.  +        		pflen = ftell(pffd);
  477.  +        		rewind(pffd);
  478.           		argstrlen += pflen;
  479.           	} else {
  480.           		pflen = 0;
  481.           	}
  482.           
  483.           	/* Allocate space for command line and parameter file
  484.           		plus nulls at the ends to help with parsing. */
  485.           	/* argstr = (char *) calloc((size_t) (1+argstrlen+1), 1); */
  486.           	/*argstr = (char *) ealloc1(1+argstrlen+1, 1);*/
  487.           	argstr = (char *) calloc((size_t) (1+argstrlen+1), 1);
  488.           
  489.           	if (parfile) {
  490.           		/* Read the parfile */
  491.  +        		nread = fread(argstr + 1, 1, pflen, pffd);
  492.             		if (nread != pflen) {
  493.  +          	 	    err("%s: fread only %d bytes out of %d from %s",
  494.             					__FILE__,  nread, pflen, pfname);
  495.           		}
  496.  +        		fclose(pffd);
  497.           
  498.           		/* Zap whites in parfile to help in parsing */
  499.  +        		pfargc = white2null(argstr, pflen);
  500.           
  501.           	} else {
  502.           		pfargc = 0;
  503.           	}
  504.           
  505.           	/* Total arg count */
  506.           	targc = pfargc + xargc - 1;
  507.           
  508.           	/* Allocate space for total arg pointers */
  509.           	targv = (char **) calloc(targc, sizeof(char*));
  510.           
  511.           	if (parfile) {
  512.           		/* Parse the parfile.  Skip over multiple NULLs */
  513.  + r4---< 		for (j = 1, i = 0; j < pflen; j++) {
  514.    r4     			if (argstr[j] && !argstr[j-1]) {
  515.    r4     			       targv[i++] = argstr + j;
  516.    r4     			}
  517.    r4---> 		}
  518.           	} else {
  519.           		i = 0;
  520.           	}
  521.           
  522.           	/* Copy command line arguments */
  523.  + 1----< 	for (j = 1, pargstr = argstr + pflen + 2; j < xargc; j++) {
  524.  + 1      		strcpy(pargstr,xargv[j]);
  525.    1      		targv[i++] = pargstr;
  526.    1      		pargstr += strlen(xargv[j]) + 1;
  527.    1----> 	}
  528.           
  529.           	/* Allocate space for the pointer table */
  530.           	argtbl = (pointer_table*) calloc(targc, sizeof(pointer_table));
  531.           
  532.           	/* Tabulate targv */
  533.  +  Ip--> 	tabulate(targc, targv);
  534.           	
  535.           	return;
  536.           }
  537.           
  538.           #define PFNAME "par="
  539.           /* Get name of parameter file */
  540.           static char *getpfname (void)
  541.           {
  542.           	int i;
  543.           	int pfnamelen;
  544.           
  545.           	pfnamelen = strlen(PFNAME);
  546.  + F----< 	for (i = xargc-1 ; i > 0 ; i--) {
  547.    F      		if(!strncmp(PFNAME, xargv[i], pfnamelen)
  548.    F      		    && strlen(xargv[i]) != pfnamelen) {
  549.    F      			return xargv[i] + pfnamelen;
  550.    F      		}	
  551.    F----> 	}
  552.           	return NULL;
  553.           }
  554.           
  555.           #define iswhite(c)	((c) == ' ' || (c) == '\t' || (c) == '\n')
  556.           
  557.           /* 
  558.            * Replace the whites by (possibly multiple) nulls.  If we see a non-white
  559.            * and the previous char is a null, this signals the start of a string
  560.            * and we bump the count.  This routine returns a count of the strings.
  561.            */
  562.           static int white2null (char *str, int len)
  563.           {
  564.           	int i;
  565.           	int count;
  566.           	int inquote = FALSE;
  567.           
  568.           	str[0] = '\0'; /* This line added by Dave Hale, 1/30/96. */
  569.  + r4---< 	for (i = 1, count = 0; i < len; i++) {
  570.    r4     		if (str[i]=='"') inquote=(inquote==TRUE)?FALSE:TRUE;
  571.    r4     		if (!inquote) {
  572.    r4     			if (iswhite(str[i])) { /* Is this a new word ? */
  573.    r4     				str[i] = '\0';
  574.    r4     			} else if (!str[i-1]) { /* multiple whites */
  575.    r4     				count++;
  576.    r4     			}
  577.    r4     		}
  578.    r4---> 	}
  579.  + r4---< 	for (i = 1, inquote=FALSE; i < len; i++) {
  580.    r4     		if (str[i]=='"') inquote=(inquote==TRUE)?FALSE:TRUE;
  581.    r4     		if (inquote) {
  582.    r4     			if (str[i+1]!='"') {
  583.    r4     				str[i] = str[i+1];
  584.    r4     			} else {
  585.    r4     				str[i] = '\0';
  586.    r4     				str[i+1] = '\0';
  587.    r4     				inquote = FALSE;
  588.    r4     			}
  589.    r4     		}
  590.    r4---> 	}
  591.           	str[len] = '\0';
  592.           	return count;
  593.           }
  594.           
  595.           /* Install symbol table */
  596.           static void tabulate (int argc, char **argv)
  597.           {
  598.           	int i;
  599.           	char *eqptr;
  600.           
  601.  + F----< 	for (i = 0, nargs = 0 ; i < argc; i++) {
  602.    F      		eqptr = (char *)strchr(argv[i], '=');
  603.    F      		if (eqptr) {
  604.    F      			argtbl[nargs].name = argv[i];
  605.    F      			argtbl[nargs].asciival = eqptr + 1;
  606.    F      			*eqptr = (char)0;
  607.    F      
  608.    F      			/* Debugging dump */
  609.    F      /* 			fprintf(stderr, */
  610.    F      /* 			"argtbl[%d]: name=%s asciival=%s\n", */
  611.    F      /* 			nargs,argtbl[nargs].name,argtbl[nargs].asciival); */
  612.    F      
  613.    F      			nargs++;
  614.    F      		}
  615.    F----> 	}
  616.           	return;
  617.           }
  618.           
  619.           /* Count characters in a string */
  620.           static int ccount (char c, char *s)
  621.           {
  622.           	int i, count;
  623.  + 1----< 	for (i = 0, count = 0; s[i] != 0; i++)
  624.    1----> 		if(s[i] == c) count++;
  625.           	return count;
  626.           }
  627.           
  628.           static void strchop(char *s, char *t)
  629.           /***********************************************************************
  630.           strchop - chop off the tail end of a string "s" after a "," returning
  631.                     the front part of "s" as "t".
  632.           ************************************************************************
  633.           Notes:
  634.           Based on strcpy in Kernighan and Ritchie's C [ANSI C] book, p. 106.
  635.           ************************************************************************
  636.           Author: CWP: John Stockwell and Jack K. Cohen, July 1995
  637.           ***********************************************************************/
  638.           {
  639.           
  640.  + 1----< 	while ( (*s != ',') && (*s != '\0') ) {
  641.    1      		 *t++ = *s++;
  642.    1----> 	}
  643.           	*t='\0';
  644.           }
  645.           
  646.           
  647.           #ifdef TEST
  648.           #define N 100
  649.           main(int argc, char **argv)
  650.           {
  651.           	char *s;
  652.           	short h, vh[N];
  653.           	unsigned short u, vu[N];
  654.           	long l, vl[N];
  655.           	unsigned long v, vv[N];
  656.           	int i, vi[N], ipar, npar, nval;
  657.           	unsigned int p, vp[N];
  658.           	float f, vf[N];
  659.           	double d, vd[N];
  660.           
  661.           	initargs(argc, argv);
  662.           
  663.           	/* int parameters */
  664.           	npar = countparname("i");
  665.           	printf("\nnumber of i pars = %d\n",npar);
  666.           	for (ipar=1; ipar<=npar; ++ipar) {
  667.           		getnparint(ipar,"i",&i);
  668.           		printf("occurrence %d of i=%d\n",ipar,i);
  669.           	}
  670.           	if (getparint("i", &i))	
  671.           		printf("last occurrence of i=%d\n",i);
  672.           	npar = countparname("vi");
  673.           	printf("number of vi pars = %d\n",npar);
  674.           	for (ipar=1; ipar<=npar; ++ipar) {
  675.           		nval = countnparval(ipar,"vi");
  676.           		printf("occurrence %d has %d values\n",ipar,nval);
  677.           		nval = getnparint(ipar,"vi",vi);
  678.           		printf("vi=");
  679.           		for (i=0; i<nval; i++)
  680.           			printf("%d%c",vi[i],i==nval-1?'\n':',');
  681.           	}
  682.           	if (npar>0) {
  683.           		nval = countparval("vi");
  684.           		printf("last occurrence has %d values\n",nval);
  685.           		getparint("vi",vi);
  686.           		printf("vi=");
  687.           		for (i=0; i<nval; i++)
  688.           			printf("%d%c",vi[i],i==nval-1?'\n':',');
  689.           	}
  690.           
  691.           	/* float parameters */
  692.           	npar = countparname("f");
  693.           	printf("\nnumber of f pars = %d\n",npar);
  694.           	for (ipar=1; ipar<=npar; ++ipar) {
  695.           		getnparfloat(ipar,"f",&f);
  696.           		printf("occurrence %d of f=%g\n",ipar,f);
  697.           	}
  698.           	if (getparfloat("f", &f))	
  699.           		printf("last occurrence of f=%g\n",f);
  700.           	npar = countparname("vf");
  701.           	printf("number of vf pars = %d\n",npar);
  702.           	for (ipar=1; ipar<=npar; ++ipar) {
  703.           		nval = countnparval(ipar,"vf");
  704.           		printf("occurrence %d has %d values\n",ipar,nval);
  705.           		nval = getnparfloat(ipar,"vf",vf);
  706.           		printf("vf=");
  707.           		for (i=0; i<nval; i++)
  708.           			printf("%g%c",vf[i],i==nval-1?'\n':',');
  709.           	}
  710.           	if (npar>0) {
  711.           		nval = countparval("vf");
  712.           		printf("last occurrence has %d values\n",nval);
  713.           		getparfloat("vf",vf);
  714.           		printf("vf=");
  715.           		for (i=0; i<nval; i++)
  716.           			printf("%g%c",vf[i],i==nval-1?'\n':',');
  717.           	}
  718.           
  719.           	/* string parameters */
  720.           	npar = countparname("s");
  721.           	printf("\nnumber of s pars = %d\n",npar);
  722.           	for (ipar=1; ipar<=npar; ++ipar) {
  723.           		getnparstring(ipar,"s",&s);
  724.           		printf("occurrence %d of s=%s\n",ipar,s);
  725.           	}
  726.           	if (getparstring("s", &s))	
  727.           		printf("last occurrence of s=%s\n",s);
  728.           	
  729.           	return EXIT_SUCCESS;
  730.           }
  731.           #endif
  732.           

CC-3118 CC: IPA File = getpars.c, Line = 216 
  "getnpar" (called from "getparint") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 220 
  "getnpar" (called from "getparuint") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 224 
  "getnpar" (called from "getparshort") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 228 
  "getnpar" (called from "getparushort") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 232 
  "getnpar" (called from "getparlong") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 236 
  "getnpar" (called from "getparulong") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 240 
  "getnpar" (called from "getparfloat") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 244 
  "getnpar" (called from "getpardouble") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 248 
  "getnpar" (called from "getparstring") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 252 
  "getnpar" (called from "getparstringarray") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 256 
  "getnpar" (called from "getpar") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 262 
  "getnpar" (called from "getnparint") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 266 
  "getnpar" (called from "getnparuint") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 270 
  "getnpar" (called from "getnparshort") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 274 
  "getnpar" (called from "getnparushort") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 278 
  "getnpar" (called from "getnparlong") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 282 
  "getnpar" (called from "getnparulong") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 286 
  "getnpar" (called from "getnparfloat") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 290 
  "getnpar" (called from "getnpardouble") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 294 
  "getnpar" (called from "getnparstring") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 298 
  "getnpar" (called from "getnparstringarray") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 307 
  "getparinit" (called from "getnpar") was not inlined because the call site will not flatten.  "strcpy" is missing.

CC-3171 CC: IPA File = getpars.c, Line = 308 
  "getparindex" (called from "getnpar") was not inlined because it is not in the body of a loop.

CC-6287 CC: VECTOR File = getpars.c, Line = 321 
  A loop was not vectorized because it contains a call to function "eatoi" on line 324.

CC-3021 CC: IPA File = getpars.c, Line = 324 
  "eatoi" (called from "getnpar") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getpars.c, Line = 328 
  "eatop" (called from "getnpar") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getpars.c, Line = 332 
  "eatoh" (called from "getnpar") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getpars.c, Line = 336 
  "eatou" (called from "getnpar") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getpars.c, Line = 340 
  "eatol" (called from "getnpar") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getpars.c, Line = 344 
  "eatov" (called from "getnpar") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getpars.c, Line = 348 
  "eatof" (called from "getnpar") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getpars.c, Line = 352 
  "eatod" (called from "getnpar") was not inlined because the compiler was unable to locate the routine.

CC-3172 CC: IPA File = getpars.c, Line = 359 
  "strchop" (called from "getnpar") was not inlined because the enclosing loop body did not completely flatten.

CC-3021 CC: IPA File = getpars.c, Line = 365 
  "err" (called from "getnpar") was not inlined because the compiler was unable to locate the routine.

CC-6254 CC: VECTOR File = getpars.c, Line = 368 
  A loop was not vectorized because a recurrence was found on "aval" at line 368.

CC-3118 CC: IPA File = getpars.c, Line = 377 
  "getnpar" (called from "getPar") was not inlined because the call site will not flatten.  "err" is missing.

CC-3118 CC: IPA File = getpars.c, Line = 387 
  "getparinit" (called from "countparname") was not inlined because the call site will not flatten.  "strcpy" is missing.

CC-6287 CC: VECTOR File = getpars.c, Line = 388 
  A loop was not vectorized because it contains a call to function "strcmp" on line 389.

CC-3182 CC: IPA File = getpars.c, Line = 388 
  Loop has been flattened.

CC-3118 CC: IPA File = getpars.c, Line = 399 
  "getparinit" (called from "countnparval") was not inlined because the call site will not flatten.  "strcpy" is missing.

CC-3171 CC: IPA File = getpars.c, Line = 400 
  "getparindex" (called from "countnparval") was not inlined because it is not in the body of a loop.

CC-6254 CC: VECTOR File = getpars.c, Line = 402 
  A loop was not vectorized because a recurrence was found on "i" at line 402.

CC-3001 CC: IPA File = getpars.c, Line = 402 
  The call to tiny leaf routine "ccount" was textually inlined.

CC-3118 CC: IPA File = getpars.c, Line = 410 
  "countnparval" (called from "countparval") was not inlined because the call site will not flatten.  "strcpy" is missing.

CC-6287 CC: VECTOR File = getpars.c, Line = 424 
  A loop was not vectorized because it contains a call to function "strcmp" on line 425.

CC-3182 CC: IPA File = getpars.c, Line = 424 
  Loop has been flattened.

CC-6287 CC: VECTOR File = getpars.c, Line = 428 
  A loop was not vectorized because it contains a call to function "strcmp" on line 429.

CC-3182 CC: IPA File = getpars.c, Line = 428 
  Loop has been flattened.

CC-3021 CC: IPA File = getpars.c, Line = 456 
  "err" (called from "getparinit") was not inlined because the compiler was unable to locate the routine.

CC-6287 CC: VECTOR File = getpars.c, Line = 459 
  A loop was not vectorized because it contains a call to function "strlen" on line 460.

CC-3182 CC: IPA File = getpars.c, Line = 459 
  Loop has been flattened.

CC-6287 CC: VECTOR File = getpars.c, Line = 465 
  A loop was not vectorized because it contains a call to function "strncmp" on line 465.

CC-3001 CC: IPA File = getpars.c, Line = 465 
  The call to tiny routine "getpfname" was textually inlined.  NOT INLINED:  strlen : strncmp.

CC-3021 CC: IPA File = getpars.c, Line = 472 
  "fopen" (called from "getparinit") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getpars.c, Line = 475 
  "fseek" (called from "getparinit") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getpars.c, Line = 476 
  "ftell" (called from "getparinit") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getpars.c, Line = 477 
  "rewind" (called from "getparinit") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getpars.c, Line = 491 
  "fread" (called from "getparinit") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getpars.c, Line = 493 
  "err" (called from "getparinit") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = getpars.c, Line = 496 
  "fclose" (called from "getparinit") was not inlined because the compiler was unable to locate the routine.

CC-3171 CC: IPA File = getpars.c, Line = 499 
  "white2null" (called from "getparinit") was not inlined because it is not in the body of a loop.

CC-6005 CC: SCALAR File = getpars.c, Line = 513 
  A loop was unrolled 4 times.

CC-6290 CC: VECTOR File = getpars.c, Line = 513 
  A loop was not vectorized because a recurrence was found between "argstr" and "targv" at line 515.

CC-6287 CC: VECTOR File = getpars.c, Line = 523 
  A loop was not vectorized because it contains a call to function "strcpy" on line 524.

CC-3021 CC: IPA File = getpars.c, Line = 524 
  "strcpy" (called from "getparinit") was not inlined because the compiler was unable to locate the routine.

CC-6287 CC: VECTOR File = getpars.c, Line = 533 
  A loop was not vectorized because it contains a call to function "strchr" on line 533.

CC-3001 CC: IPA File = getpars.c, Line = 533 
  The call to tiny routine "tabulate" was textually inlined.  NOT INLINED:  strchr.

CC-6287 CC: VECTOR File = getpars.c, Line = 546 
  A loop was not vectorized because it contains a call to function "strncmp" on line 547.

CC-3182 CC: IPA File = getpars.c, Line = 546 
  Loop has been flattened.

CC-6005 CC: SCALAR File = getpars.c, Line = 569 
  A loop was unrolled 4 times.

CC-6254 CC: VECTOR File = getpars.c, Line = 569 
  A loop was not vectorized because a recurrence was found on "str" at line 573.

CC-6005 CC: SCALAR File = getpars.c, Line = 579 
  A loop was unrolled 4 times.

CC-6289 CC: VECTOR File = getpars.c, Line = 579 
  A loop was not vectorized because a recurrence was found on "str" between lines 583 and 586.

CC-6287 CC: VECTOR File = getpars.c, Line = 601 
  A loop was not vectorized because it contains a call to function "strchr" on line 602.

CC-3182 CC: IPA File = getpars.c, Line = 601 
  Loop has been flattened.

CC-6254 CC: VECTOR File = getpars.c, Line = 623 
  A loop was not vectorized because a recurrence was found on "i" at line 623.

CC-6290 CC: VECTOR File = getpars.c, Line = 640 
  A loop was not vectorized because a recurrence was found between "s" and "t" at line 641.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
