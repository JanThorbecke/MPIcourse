%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          S u m m a r y   R e p o r t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Compilation
-----------
File     : /cray/css/u19/jan/src/3DFD/readModel.c
Compiled : 2015-09-11  08:11:48
Compiler : Version 8.4.0.223
Ftnlx    : Version 8412 (libcif 84005)
Target   : x86-64
Command  : driver.cc -h cpu=haswell -h dynamic -D __CRAYCS -D __CRAY_HASWELL
           -D __CRAYXT_COMPUTE_LINUX_TARGET -O 3 -h fp3 -h noomp -h list=a -I .
           -c readModel.c -W l,--rpath=/opt/cray/cce/8.4.0.223/craylibs/x86-64
           -ibase-compiler /opt/cray/cce/8.4.0.223/CC/x86-64/compiler_include_ba
           se -isystem /opt/cray/cce/8.4.0.223/craylibs/x86-64/include
           -isystem /usr/local/cuda/include
           -I /opt/gcc/4.8.1/snos/lib/gcc/x86_64-suse-linux/4.8.1/include
           -I /opt/gcc/4.8.1/snos/lib/gcc/x86_64-suse-linux/4.8.1/include-fixed
           -I /opt/cray/mvapich2_slurm/2.0.1.4/CRAY/8.4/include
           -I /opt/cray/libsci/13.2.0.1/CRAY/8.3/x86_64/include
           -I /global/opt/nvidia/cudatoolkit/7.0.28/include
           -I /opt/cray/cce/8.4.0.223/craylibs/x86-64/include

clx report
------------
Source   : /cray/css/u19/jan/src/3DFD/readModel.c
Date     : 09/11/2015  08:11:50


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          O p t i o n s   R e p o r t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Options :  -h cache2,fp3,scalar3,thread2,vector3,mpi0,ipa3,noaggress         
           -h autoprefetch,noautothread,fusion2,nomsgs,nonegmsgs         
           -h nooverindex,pattern,unroll2,nozeroinc         
           -h noadd_paren,noupc,dwarf,nofp_trap,nofunc_trace         
           -h noomp_analyze,noomp_trace,nopat_trace         
           -h noomp,noomp_acc,noacc         
           -h c99,noexceptions,nostrict,noinfinitevl         
           -h notolerant,gnu         
           -h flex_mp=default         
           -h cpu=x86-64,haswell
           -h network=gemini         
           -K trap=none 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          S o u r c e   L i s t i n g
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


     %%%    L o o p m a r k   L e g e n d    %%%

     Primary Loop Type        Modifiers
     ------- ---- ----        ---------
     A - Pattern matched      a - atomic memory operation
                              b - blocked
     C - Collapsed            c - conditional and/or computed
     D - Deleted               
     E - Cloned                
     F - Flat - No calls      f - fused
     G - Accelerated          g - partitioned
     I - Inlined              i - interchanged
     M - Multithreaded        m - partitioned
                              n - non-blocking remote transfer
                              p - partial
                              r - unrolled
                              s - shortloop
     V - Vectorized           w - unwound

     + - More messages listed at end of listing
     ------------------------------------------


    1.              #define _FILE_OFFSET_BITS 64
    2.              #define _LARGEFILE_SOURCE
    3.              #define _LARGEFILE64_SOURCE
    4.              
    5.              #include <assert.h>
    6.              #include <stdio.h>
    7.              #include <stdlib.h>
    8.              #include <errno.h>
    9.              #include <math.h>
   10.              #include "segy.h"
   11.              #include "par.h"
   12.              #include "fdelmodc.h"
   13.              
   14.              #define     MAX(x,y) ((x) > (y) ? (x) : (y))
   15.              #define     MIN(x,y) ((x) < (y) ? (x) : (y))
   16.              #define NINT(x) ((int)((x)>0.0?(x)+0.5:(x)-0.5))
   17.              
   18.              int writesufile(char *filename, float *data, int n1, int n2, float f1, float f2, float d1, float d2);
   19.              
   20.              /**
   21.              *  Reads gridded model files and compute from them medium parameters used in the FD kernels.
   22.              *  The files read in contain the P (and S) wave velocity and density.
   23.              *  The medium parameters calculated are lambda, mu, lambda+2mu, and 1/ro.
   24.              *
   25.              *   AUTHOR:
   26.              *           Jan Thorbecke (janth@xs4all.nl)
   27.              *           The Netherlands 
   28.              **/
   29.              
   30.              
   31.              int readModel(modPar mod, bndPar bnd, float *rox, float *roz, float *l2m, float *lam, float *muu, float *tss, float *tes, float *tep)
   32.              {
   33.                  FILE    *fpcp, *fpcs, *fpro;
   34.              	FILE    *fpqp=NULL, *fpqs=NULL;
   35.                  size_t  nread;
   36.                  int i, tracesToDo;
   37.              	int n1, ix, iz, nz, nx;
   38.                  int ixo, izo, ixe, ize;
   39.              	int ioXx, ioXz, ioZz, ioZx, ioPx, ioPz, ioTx, ioTz;
   40.              	float cp2, cs2, cs11, cs12, cs21, cs22, mul, mu, lamda2mu, lamda;
   41.              	float cs2c, cs2b, cs2a, cpx, cpz, bx, bz, fac;
   42.              	float *cp, *cs, *ro, *qp, *qs;
   43.              	float a, b;
   44.                  segy hdr;
   45.                  
   46.              
   47.              	/* grid size and start positions for the components */
   48.              	nz = mod.nz;
   49.              	nx = mod.nx;
   50.              	n1 = mod.naz;
   51.              	fac = mod.dt/mod.dx;
   52.              
   53.              	/* Vx: rox */
   54.              	ioXx=mod.ioXx;
   55.              	ioXz=mod.ioXz;
   56.              	/* Vz: roz */
   57.              	ioZz=mod.ioZz;
   58.              	ioZx=mod.ioZx;
   59.              	/* P, Txx, Tzz: lam, l2m */
   60.              	ioPx=mod.ioPx;
   61.              	ioPz=mod.ioPz;
   62.              	/* Txz: muu */
   63.              	ioTx=mod.ioTx;
   64.              	ioTz=mod.ioTz;
   65.                  if (bnd.lef==4 || bnd.lef==2) {
   66.              		ioPx += bnd.ntap;
   67.              		ioTx += bnd.ntap;
   68.              	}
   69.                  if (bnd.top==4 || bnd.top==2) {
   70.              		ioPz += bnd.ntap;
   71.              		ioTz += bnd.ntap;
   72.              	}
   73.              
   74.              /* open files and read first header */
   75.              
   76.              	cp = (float *)malloc(nz*nx*sizeof(float));
   77.  +              	fpcp = fopen( mod.file_cp, "r" );
   78.  +              	assert( fpcp != NULL);
   79.  +              	nread = fread(&hdr, 1, TRCBYTES, fpcp);
   80.  +              	assert(nread == TRCBYTES);
   81.              
   82.              	ro = (float *)malloc(nz*nx*sizeof(float));
   83.  +              	fpro = fopen( mod.file_ro, "r" );
   84.  +              	assert( fpro != NULL);
   85.  +              	nread = fread(&hdr, 1, TRCBYTES, fpro);
   86.  +              	assert(nread == TRCBYTES);
   87.              
   88.              	if (mod.ischeme>2) {
   89.              		cs = (float *)malloc(nz*nx*sizeof(float));
   90.  +           		fpcs = fopen( mod.file_cs, "r" );
   91.  +              		assert( fpcs != NULL);
   92.  +              		nread = fread(&hdr, 1, TRCBYTES, fpcs);
   93.  +              		assert(nread == TRCBYTES);
   94.              	}
   95.              
   96.              /* for visco acoustic/elastic media open Q file(s) if given as parameter */
   97.              
   98.              	if (mod.file_qp != NULL && (mod.ischeme==2 || mod.ischeme==4)) {
   99.              		qp = (float *)malloc(nz*sizeof(float));
  100.  +           		fpqp = fopen( mod.file_qp, "r" );
  101.  +              		assert( fpqp != NULL);
  102.  +              		nread = fread(&hdr, 1, TRCBYTES, fpqp);
  103.  +              		assert(nread == TRCBYTES);
  104.              	}
  105.              	if (mod.file_qs != NULL && mod.ischeme==4) {
  106.              		qs = (float *)malloc(nz*sizeof(float));
  107.  +           		fpqs = fopen( mod.file_qs, "r" );
  108.  +              		assert( fpqs != NULL);
  109.  +              		nread = fread(&hdr, 1, TRCBYTES, fpqs);
  110.  +              		assert(nread == TRCBYTES);
  111.              	}
  112.              
  113.              
  114.              /* read all traces */
  115.              
  116.              	tracesToDo = mod.nx;
  117.              	i = 0;
  118.  + 1-------< 	while (tracesToDo) {
  119.  + 1                	nread = fread(&cp[i*nz], sizeof(float), hdr.ns, fpcp);
  120.  + 1                	assert (nread == hdr.ns);
  121.  + 1                	nread = fread(&ro[i*nz], sizeof(float), hdr.ns, fpro);
  122.  + 1                	assert (nread == hdr.ns);
  123.    1         		if (mod.ischeme>2) {
  124.  + 1                		nread = fread(&cs[i*nz], sizeof(float), hdr.ns, fpcs);
  125.  + 1                		assert (nread == hdr.ns);
  126.    1         		}
  127.    1         
  128.    1         /*************************************************************
  129.    1         
  130.    1         	Converts the Qp,Qs-value to tau-epsilon and tau-sigma
  131.    1         
  132.    1               tau-sigma    = (sqrt(1.0+(1.0/Qp**2))-(1.0/Qp))/w
  133.    1               tau-epsilonP = 1.0/(w*w*tau-sigma)
  134.    1               tau-epsilonS = (1.0+(w*Qs*tau-sigma))/(w*Qs-(w*w*tau-sigma));
  135.    1         
  136.    1         *************************************************************/
  137.    1         
  138.    1         		/* visco-acoustic */
  139.    1         		if (mod.ischeme==2 || mod.ischeme==4) {
  140.    1         			if (mod.file_qp != NULL) {
  141.  + 1                			nread = fread(&qp[0], sizeof(float), nz, fpqp);
  142.  + 1                			assert (nread == hdr.ns);
  143.  + 1 2-----< 				for (iz=0; iz<nz; iz++) {
  144.    1 2       					a = sqrt(1.0+(1.0/(qp[iz]*qp[iz]))-(1.0/qp[iz]))/mod.fw;
  145.    1 2       					b = 1.0/(mod.fw*mod.fw*a);
  146.    1 2       					tss[(i+ioPx)*n1+iz+ioPz] = 1.0/a;
  147.    1 2       					tep[(i+ioPx)*n1+iz+ioPz] = b;
  148.    1 2-----> 				}
  149.    1         			}
  150.    1         			else {
  151.    1 Vcr2--< 				for (iz=0; iz<nz; iz++) {
  152.    1 Vcr2    					a = sqrt(1.0+(1.0/(mod.Qp*mod.Qp))-(1.0/mod.Qp))/mod.fw;
  153.    1 Vcr2    					b = 1.0/(mod.fw*mod.fw*a);
  154.    1 Vcr2    					tss[(i+ioPx)*n1+iz+ioPz] = 1.0/a;
  155.    1 Vcr2    					tep[(i+ioPx)*n1+iz+ioPz] = b;
  156.    1 Vcr2--> 				}
  157.    1         			}
  158.    1         		}
  159.    1         
  160.    1         		/* visco-elastic */
  161.    1         		if (mod.ischeme==4) {
  162.    1         			if (mod.file_qs != NULL) {
  163.  + 1                			nread = fread(&qs[0], sizeof(float), hdr.ns, fpqs);
  164.  + 1                			assert (nread == hdr.ns);
  165.    1 Vcr2--< 				for (iz=0; iz<nz; iz++) {
  166.    1 Vcr2    					a = 1.0/tss[(i+ioPx)*n1+iz+ioPz];
  167.    1 Vcr2    					tes[(i+ioPx)*n1+iz+ioPz] = (1.0+(mod.fw*qs[iz]*a))/(mod.fw*qs[iz]-(mod.fw*mod.fw*a));
  168.    1 Vcr2--> 				}
  169.    1         			}
  170.    1         			else {
  171.    1 Vcr2--< 				for (iz=0; iz<nz; iz++) {
  172.    1 Vcr2    					a = 1.0/tss[(i+ioPx)*n1+iz+ioPz];
  173.    1 Vcr2    					tes[(i+ioPx)*n1+iz+ioPz] = (1.0+(mod.fw*mod.Qs*a))/(mod.fw*mod.Qs-(mod.fw*mod.fw*a));
  174.    1 Vcr2--> 				}
  175.    1         			}
  176.    1         		}
  177.    1         
  178.  + 1                	nread = fread(&hdr, 1, TRCBYTES, fpcp);
  179.    1                	if (nread==0) break;
  180.  + 1                	nread = fread(&hdr, 1, TRCBYTES, fpro);
  181.    1                	if (nread==0) break;
  182.    1         		if (mod.ischeme>2) {
  183.  + 1                		nread = fread(&hdr, 1, TRCBYTES, fpcs);
  184.    1                		if (nread==0) break;
  185.    1         		}
  186.    1         		if (mod.file_qp != NULL && (mod.ischeme==2 || mod.ischeme==4)) {
  187.  + 1                		nread = fread(&hdr, 1, TRCBYTES, fpqp);
  188.    1                		if (nread==0) break;
  189.    1         		}
  190.    1         		if (mod.file_qs != NULL && mod.ischeme==4) {
  191.  + 1                		nread = fread(&hdr, 1, TRCBYTES, fpqs);
  192.    1                		if (nread==0) break;
  193.    1         		}
  194.    1         		i++;
  195.    1-------> 	}
  196.  +              	fclose(fpcp);
  197.  +              	fclose(fpro);
  198.  +              	if (mod.ischeme>2) fclose(fpcs);
  199.  +           	if (fpqp != NULL) fclose(fpqp);
  200.  +           	if (fpqs != NULL) fclose(fpqs);
  201.              
  202.              /* check for zero densities */
  203.              
  204.  + 1-------< 	for (i=0;i<nz*nx;i++) {
  205.    1         		if (ro[i]==0.0) {
  206.  + 1         			vwarn("Zero density for trace=%d sample=%d", i/nz, i%nz);
  207.  + 1         			verr("ERROR zero density is not a valid value, program exit");
  208.    1         		}
  209.    1-------> 	}
  210.              
  211.              /* calculate the medium parameter grids needed for the FD scheme */
  212.              
  213.              /* the edges of the model */
  214.              
  215.              	if (mod.ischeme>2) { /* Elastic Scheme */
  216.              		iz = nz-1;
  217.  + 1-------< 		for (ix=0;ix<nx-1;ix++) {
  218.    1         			cp2  = cp[ix*nz+iz]*cp[ix*nz+iz];
  219.    1         			cs2  = cs[ix*nz+iz]*cs[ix*nz+iz];
  220.    1         			cs2a = cs[(ix+1)*nz+iz]*cs[(ix+1)*nz+iz];
  221.    1         			cs11 = cs2*ro[ix*nz+iz];
  222.    1         			cs12 = cs2*ro[ix*nz+iz];
  223.    1         			cs21 = cs2a*ro[(ix+1)*nz+iz];
  224.    1         			cs22 = cs2a*ro[(ix+1)*nz+iz];
  225.    1         //			cpx  = 0.5*(cp[ix*nz+iz]+cp[(ix+1)*nz+iz])
  226.    1         //			cpz  = cp[ix*nz+iz];
  227.    1         
  228.    1         			if (cs11 > 0.0) {
  229.    1         				mul  = 4.0/(1.0/cs11+1.0/cs12+1.0/cs21+1.0/cs22);
  230.    1         			}
  231.    1         			else {
  232.    1         				mul = 0.0;
  233.    1         			}
  234.    1         			mu   = cs2*ro[ix*nz+iz];
  235.    1         			lamda2mu = cp2*ro[ix*nz+iz];
  236.    1         			lamda    = lamda2mu - 2*mu;
  237.    1         
  238.    1         			bx = 0.5*(ro[ix*nz+iz]+ro[(ix+1)*nz+iz]);
  239.    1         			bz = ro[ix*nz+iz];
  240.    1         			rox[(ix+ioXx)*n1+iz+ioXz]=fac/bx;
  241.    1         			roz[(ix+ioZx)*n1+iz+ioZz]=fac/bz;
  242.    1         			l2m[(ix+ioPx)*n1+iz+ioPz]=fac*lamda2mu;
  243.    1         			lam[(ix+ioPx)*n1+iz+ioPz]=fac*lamda;
  244.    1         			muu[(ix+ioTx)*n1+iz+ioTz]=fac*mul;
  245.    1-------> 		}
  246.              
  247.              		ix = nx-1;
  248.  + 1-------< 		for (iz=0;iz<nz-1;iz++) {
  249.    1         			cp2  = cp[ix*nz+iz]*cp[ix*nz+iz];
  250.    1         			cs2  = cs[ix*nz+iz]*cs[ix*nz+iz];
  251.    1         			cs2b = cs[ix*nz+iz+1]*cs[ix*nz+iz+1];
  252.    1         			cs11 = cs2*ro[ix*nz+iz];
  253.    1         			cs12 = cs2b*ro[ix*nz+iz+1];
  254.    1         			cs21 = cs2*ro[ix*nz+iz];
  255.    1         			cs22 = cs2b*ro[ix*nz+iz+1];
  256.    1         //			cpx  = cp[ix*nz+iz];
  257.    1         //			cpz  = 0.5*(cp[ix*nz+iz]+cp[ix*nz+iz+1]);
  258.    1         
  259.    1         			if (cs11 > 0.0) {
  260.    1         				mul  = 4.0/(1.0/cs11+1.0/cs12+1.0/cs21+1.0/cs22);
  261.    1         			}
  262.    1         			else {
  263.    1         				mul = 0.0;
  264.    1         			}
  265.    1         			mu   = cs2*ro[ix*nz+iz];
  266.    1         			lamda2mu = cp2*ro[ix*nz+iz];
  267.    1         			lamda    = lamda2mu - 2*mu;
  268.    1         
  269.    1         			bx = ro[ix*nz+iz];
  270.    1         			bz = 0.5*(ro[ix*nz+iz]+ro[ix*nz+iz+1]);
  271.    1         			rox[(ix+ioXx)*n1+iz+ioXz]=fac/bx;
  272.    1         			roz[(ix+ioZx)*n1+iz+ioZz]=fac/bz;
  273.    1         			l2m[(ix+ioPx)*n1+iz+ioPz]=fac*lamda2mu;
  274.    1         			lam[(ix+ioPx)*n1+iz+ioPz]=fac*lamda;
  275.    1         			muu[(ix+ioTx)*n1+iz+ioTz]=fac*mul;
  276.    1-------> 		}
  277.              		ix=nx-1;
  278.              		iz=nz-1;
  279.              		cp2  = cp[ix*nz+iz]*cp[ix*nz+iz];
  280.              		cs2  = cs[ix*nz+iz]*cs[ix*nz+iz];
  281.              		mu   = cs2*ro[ix*nz+iz];
  282.              		lamda2mu = cp2*ro[ix*nz+iz];
  283.              		lamda    = lamda2mu - 2*mu;
  284.              		bx = ro[ix*nz+iz];
  285.              		bz = ro[ix*nz+iz];
  286.              		rox[(ix+ioXx)*n1+iz+ioXz]=fac/bx;
  287.              		roz[(ix+ioZx)*n1+iz+ioZz]=fac/bz;
  288.              		l2m[(ix+ioPx)*n1+iz+ioPz]=fac*lamda2mu;
  289.              		lam[(ix+ioPx)*n1+iz+ioPz]=fac*lamda;
  290.              		muu[(ix+ioTx)*n1+iz+ioTz]=fac*mu;
  291.              
  292.  + 1-------< 		for (ix=0;ix<nx-1;ix++) {
  293.  + 1 2-----< 			for (iz=0;iz<nz-1;iz++) {
  294.    1 2       				cp2  = cp[ix*nz+iz]*cp[ix*nz+iz];
  295.    1 2       				cs2  = cs[ix*nz+iz]*cs[ix*nz+iz];
  296.    1 2       				cs2a = cs[(ix+1)*nz+iz]*cs[(ix+1)*nz+iz];
  297.    1 2       				cs2b = cs[ix*nz+iz+1]*cs[ix*nz+iz+1];
  298.    1 2       				cs2c = cs[(ix+1)*nz+iz+1]*cs[(ix+1)*nz+iz+1];
  299.    1 2       
  300.    1 2       /*
  301.    1 2       Compute harmonic average of mul for accurate and stable fluid-solid interface
  302.    1 2       see Finite-difference modeling of wave propagation in a fluid-solid configuration 
  303.    1 2       Robbert van Vossen, Johan O. A. Robertsson, and Chris H. Chapman
  304.    1 2       */
  305.    1 2       
  306.    1 2       				cs11 = cs2*ro[ix*nz+iz];
  307.    1 2       				cs12 = cs2b*ro[ix*nz+iz+1];
  308.    1 2       				cs21 = cs2a*ro[ix*nz+iz];
  309.    1 2       				cs22 = cs2c*ro[ix*nz+iz+1];
  310.    1 2       //				cpx  = 0.5*(cp[ix*nz+iz]+cp[(ix+1)*nz+iz])
  311.    1 2       //				cpz  = 0.5*(cp[ix*nz+iz]+cp[ix*nz+iz+1])
  312.    1 2       
  313.    1 2       				if (cs11 > 0.0) {
  314.    1 2       					mul  = 4.0/(1.0/cs11+1.0/cs12+1.0/cs21+1.0/cs22);
  315.    1 2       				}
  316.    1 2       				else {
  317.    1 2       					mul = 0.0;
  318.    1 2       				}
  319.    1 2       				mu   = cs2*ro[ix*nz+iz];
  320.    1 2       				lamda2mu = cp2*ro[ix*nz+iz];
  321.    1 2       				lamda    = lamda2mu - 2*mu; /* could also use mul to calculate lambda, but that might not be correct: question from Chaoshun Hu. Note use mu or mul as well on boundaries */
  322.    1 2       	
  323.    1 2       				bx = 0.5*(ro[ix*nz+iz]+ro[(ix+1)*nz+iz]);
  324.    1 2       				bz = 0.5*(ro[ix*nz+iz]+ro[ix*nz+iz+1]);
  325.    1 2       				rox[(ix+ioXx)*n1+iz+ioXz]=fac/bx;
  326.    1 2       				roz[(ix+ioZx)*n1+iz+ioZz]=fac/bz;
  327.    1 2       				l2m[(ix+ioPx)*n1+iz+ioPz]=fac*lamda2mu;
  328.    1 2       				lam[(ix+ioPx)*n1+iz+ioPz]=fac*lamda;
  329.    1 2       				muu[(ix+ioTx)*n1+iz+ioTz]=fac*mul;
  330.    1 2-----> 			}
  331.    1-------> 		}
  332.              
  333.              		/* for the tapered/PML boundaries */
  334.              /*
  335.              		for (ix=mod.ioXx-bnd.ntap;ix<mod.ioXx;ix++) {
  336.              			for (iz=mod.ioXz-bnd.ntap;ix<mod.naz;ix++) {
  337.              				rox[ix*n1+iz]=rox[ioXx*n1+ioXz]
  338.              			}
  339.              		}
  340.              */
  341.              
  342.              	}
  343.              	else { /* Acoustic Scheme */
  344.              		iz = nz-1;
  345.  + r2------< 		for (ix=0;ix<nx-1;ix++) {
  346.    r2        			cp2  = cp[ix*nz+iz]*cp[ix*nz+iz];
  347.    r2        //			cpx  = 0.5*(cp[ix*nz+iz]+cp[(ix+1)*nz+iz])
  348.    r2        //			cpz  = cp[ix*nz+iz];
  349.    r2        
  350.    r2        			lamda2mu = cp2*ro[ix*nz+iz];
  351.    r2        
  352.    r2        			bx = 0.5*(ro[ix*nz+iz]+ro[(ix+1)*nz+iz]);
  353.    r2        			bz = ro[ix*nz+iz];
  354.    r2        			rox[(ix+ioXx)*n1+iz+ioXz]=fac/bx;
  355.    r2        			roz[(ix+ioZx)*n1+iz+ioZz]=fac/bz;
  356.    r2        			l2m[(ix+ioPx)*n1+iz+ioPz]=fac*lamda2mu;
  357.    r2------> 		}
  358.              
  359.              		ix = nx-1;
  360.  + r2------< 		for (iz=0;iz<nz-1;iz++) {
  361.    r2        			cp2  = cp[ix*nz+iz]*cp[ix*nz+iz];
  362.    r2        //			cpx  = cp[ix*nz+iz];
  363.    r2        //			cpz  = 0.5*(cp[ix*nz+iz]+cp[ix*nz+iz+1])
  364.    r2        
  365.    r2        			lamda2mu = cp2*ro[ix*nz+iz];
  366.    r2        
  367.    r2        			bx = ro[ix*nz+iz];
  368.    r2        			bz = 0.5*(ro[ix*nz+iz]+ro[ix*nz+iz+1]);
  369.    r2        			rox[(ix+ioXx)*n1+iz+ioXz]=fac/bx;
  370.    r2        			roz[(ix+ioZx)*n1+iz+ioZz]=fac/bz;
  371.    r2        			l2m[(ix+ioPx)*n1+iz+ioPz]=fac*lamda2mu;
  372.    r2------> 		}
  373.              		ix=nx-1;
  374.              		iz=nz-1;
  375.              		cp2  = cp[ix*nz+iz]*cp[ix*nz+iz];
  376.              		lamda2mu = cp2*ro[ix*nz+iz];
  377.              		bx = ro[ix*nz+iz];
  378.              		bz = ro[ix*nz+iz];
  379.              		rox[(ix+ioXx)*n1+iz+ioXz]=fac/bx;
  380.              		roz[(ix+ioZx)*n1+iz+ioZz]=fac/bz;
  381.              		l2m[(ix+ioPx)*n1+iz+ioPz]=fac*lamda2mu;
  382.              
  383.  + 1-------< 		for (ix=0;ix<nx-1;ix++) {
  384.  + 1 r2----< 			for (iz=0;iz<nz-1;iz++) {
  385.    1 r2      				cp2  = cp[ix*nz+iz]*cp[ix*nz+iz];
  386.    1 r2      //				cpx  = 0.5*(cp[ix*nz+iz]+cp[(ix+1)*nz+iz])
  387.    1 r2      //				cpz  = 0.5*(cp[ix*nz+iz]+cp[ix*nz+iz+1])
  388.    1 r2      
  389.    1 r2      				lamda2mu = cp2*ro[ix*nz+iz];
  390.    1 r2      	
  391.    1 r2      				bx = 0.5*(ro[ix*nz+iz]+ro[(ix+1)*nz+iz]);
  392.    1 r2      				bz = 0.5*(ro[ix*nz+iz]+ro[ix*nz+iz+1]);
  393.    1 r2      				rox[(ix+ioXx)*n1+iz+ioXz]=fac/bx;
  394.    1 r2      				roz[(ix+ioZx)*n1+iz+ioZz]=fac/bz;
  395.    1 r2      				l2m[(ix+ioPx)*n1+iz+ioPz]=fac*lamda2mu;
  396.    1 r2----> 			}
  397.    1-------> 		}
  398.              	}
  399.              
  400.              	/* For topography free surface check for zero-velocity and set rox and roz also to zero */
  401.  + 1-------< 	for (ix=0;ix<nx;ix++) {
  402.  + 1 r4----< 		for (iz=0;iz<nz;iz++) {
  403.    1 r4      			if (l2m[(ix+ioPx)*n1+iz+ioPz]==0.0) {
  404.    1 r4      				rox[(ix+ioXx)*n1+iz+ioXz]=0.0;
  405.    1 r4      				roz[(ix+ioZx)*n1+iz+ioZz]=0.0;
  406.    1 r4      			}
  407.    1 r4----> 		}
  408.    1-------> 	}
  409.                  
  410.                  /*****************************************************/
  411.                  /* In case of tapered or PML boundaries extend model */
  412.                  /*****************************************************/
  413.                  
  414.                  /* Left  */
  415.                  if (bnd.lef==4 || bnd.lef==2) {
  416.                      
  417.                      /* rox field */
  418.                      ixo = mod.ioXx-bnd.ntap;
  419.                      ixe = mod.ioXx;
  420.                      izo = mod.ioXz;
  421.                      ize = mod.ieXz;
  422.  + 1-------<         for (ix=ixo; ix<ixe; ix++) {
  423.    1 Vcr2--<             for (iz=izo; iz<ize; iz++) {
  424.    1 Vcr2                    rox[ix*n1+iz] = rox[ixe*n1+iz];
  425.    1 Vcr2-->             }
  426.    1------->         }
  427.                      
  428.                      /* roz field */
  429.                      ixo = mod.ioZx-bnd.ntap;
  430.                      ixe = mod.ioZx;
  431.                      izo = mod.ioZz;
  432.                      ize = mod.ieZz;
  433.  + 1-------<         for (ix=ixo; ix<ixe; ix++) {
  434.    1 Vcr2--<             for (iz=izo; iz<ize; iz++) {
  435.    1 Vcr2                    roz[ix*n1+iz] = roz[ixe*n1+iz];
  436.    1 Vcr2-->             }
  437.    1------->         }
  438.                      /* l2m field */
  439.                      ixo = mod.ioPx;
  440.                      ixe = mod.ioPx+bnd.ntap;
  441.                      izo = mod.ioPz;
  442.                      ize = mod.iePz;
  443.  + 1-------<         for (ix=ixo; ix<ixe; ix++) {
  444.    1 Vcr2--<             for (iz=izo; iz<ize; iz++) {
  445.    1 Vcr2                    l2m[ix*n1+iz] = l2m[ixe*n1+iz];
  446.    1 Vcr2-->             }
  447.    1------->         }
  448.                      
  449.                      if (mod.ischeme>2) { /* Elastic Scheme */
  450.                      	/* lam field */
  451.                      	ixo = mod.ioPx;
  452.                      	ixe = mod.ioPx+bnd.ntap;
  453.                      	izo = mod.ioPz;
  454.                      	ize = mod.iePz;
  455.  + 1-------<         	for (ix=ixo; ix<ixe; ix++) {
  456.    1 Vcr2--<             	for (iz=izo; iz<ize; iz++) {
  457.    1 Vcr2                    	lam[ix*n1+iz] = lam[ixe*n1+iz];
  458.    1 Vcr2-->             	}
  459.    1------->         	}
  460.                          /* muu field */
  461.                          ixo = mod.ioTx;
  462.                          ixe = mod.ioTx+bnd.ntap;
  463.                          izo = mod.ioTz;
  464.                          ize = mod.ieTz;
  465.  + 1-------<             for (ix=ixo; ix<ixe; ix++) {
  466.    1 Vcr2--<                 for (iz=izo; iz<ize; iz++) {
  467.    1 Vcr2                        muu[ix*n1+iz] = muu[ixe*n1+iz];
  468.    1 Vcr2-->                 }
  469.    1------->             }
  470.                      }
  471.                      if (mod.ischeme==2 || mod.ischeme==4) {
  472.                          /* tss and tep field */
  473.                      	ixo = mod.ioPx;
  474.                      	ixe = mod.ioPx+bnd.ntap;
  475.                      	izo = mod.ioPz;
  476.                      	ize = mod.iePz;
  477.  + 1-------<         	for (ix=ixo; ix<ixe; ix++) {
  478.  + 1 r4----<             	for (iz=izo; iz<ize; iz++) {
  479.    1 r4                      	tss[ix*n1+iz] = tss[ixe*n1+iz];
  480.    1 r4                          tep[ix*n1+iz] = tep[ixe*n1+iz];
  481.    1 r4---->             	}
  482.    1------->         	}
  483.                      }
  484.                      if (mod.ischeme==4) {
  485.                          /* tes field */
  486.                      	ixo = mod.ioPx;
  487.                      	ixe = mod.ioPx+bnd.ntap;
  488.                      	izo = mod.ioPz;
  489.                      	ize = mod.iePz;
  490.  + 1-------<         	for (ix=ixo; ix<ixe; ix++) {
  491.    1 Vcr2--<             	for (iz=izo; iz<ize; iz++) {
  492.    1 Vcr2                        tes[ix*n1+iz] = tes[ixe*n1+iz];
  493.    1 Vcr2-->             	}
  494.    1------->         	}
  495.                      }
  496.              
  497.                  }
  498.                  
  499.                  /* Right  */
  500.                  if (bnd.rig==4 || bnd.rig==2) {
  501.                      
  502.                      /* rox field */
  503.                      ixo = mod.ieXx;
  504.                      ixe = mod.ieXx+bnd.ntap;
  505.                      izo = mod.ioXz;
  506.                      ize = mod.ieXz;
  507.  + 1-------<         for (ix=ixo; ix<ixe; ix++) {
  508.    1 Vcr2--<             for (iz=izo; iz<ize; iz++) {
  509.    1 Vcr2                    rox[ix*n1+iz] = rox[(ixo-1)*n1+iz];
  510.    1 Vcr2-->             }
  511.    1------->         }
  512.                      
  513.                      /* roz field */
  514.                      ixo = mod.ieZx;
  515.                      ixe = mod.ieZx+bnd.ntap;
  516.                      izo = mod.ioZz;
  517.                      ize = mod.ieZz;
  518.  + 1-------<         for (ix=ixo; ix<ixe; ix++) {
  519.    1 Vcr2--<             for (iz=izo; iz<ize; iz++) {
  520.    1 Vcr2                    roz[ix*n1+iz] = roz[(ixo-1)*n1+iz];
  521.    1 Vcr2-->             }
  522.    1------->         }
  523.                      /* l2m field */
  524.                      ixo = mod.iePx-bnd.ntap;
  525.                      ixe = mod.iePx;
  526.                      izo = mod.ioPz;
  527.                      ize = mod.iePz;
  528.  + 1-------<         for (ix=ixo; ix<ixe; ix++) {
  529.    1 Vcr2--<             for (iz=izo; iz<ize; iz++) {
  530.    1 Vcr2                    l2m[ix*n1+iz] = l2m[(ixo-1)*n1+iz];
  531.    1 Vcr2-->             }
  532.    1------->         }
  533.                      
  534.                      if (mod.ischeme>2) { /* Elastic Scheme */
  535.                      	/* lam field */
  536.                      	ixo = mod.iePx-bnd.ntap;
  537.                      	ixe = mod.iePx;
  538.                      	izo = mod.ioPz;
  539.                      	ize = mod.iePz;
  540.  + 1-------<         	for (ix=ixo; ix<ixe; ix++) {
  541.    1 Vcr2--<             	for (iz=izo; iz<ize; iz++) {
  542.    1 Vcr2                    	lam[ix*n1+iz] = lam[(ixo-1)*n1+iz];
  543.    1 Vcr2-->             	}
  544.    1------->         	}
  545.                          /* muu field */
  546.                          ixo = mod.ieTx-bnd.ntap;
  547.                          ixe = mod.ieTx;
  548.                          izo = mod.ioTz;
  549.                          ize = mod.ieTz;
  550.  + 1-------<             for (ix=ixo; ix<ixe; ix++) {
  551.    1 Vcr2--<                 for (iz=izo; iz<ize; iz++) {
  552.    1 Vcr2                        muu[ix*n1+iz] = muu[(ixo-1)*n1+iz];
  553.    1 Vcr2-->                 }
  554.    1------->             }
  555.                      }
  556.                      if (mod.ischeme==2 || mod.ischeme==4) {
  557.                          /* tss and tep field */
  558.                      	ixo = mod.iePx-bnd.ntap;
  559.                      	ixe = mod.iePx;
  560.                      	izo = mod.ioPz;
  561.                      	ize = mod.iePz;
  562.  + 1-------<         	for (ix=ixo; ix<ixe; ix++) {
  563.  + 1 r4----<             	for (iz=izo; iz<ize; iz++) {
  564.    1 r4                      	tss[ix*n1+iz] = tss[(ixo-1)*n1+iz];
  565.    1 r4                          tep[ix*n1+iz] = tep[(ixo-1)*n1+iz];
  566.    1 r4---->             	}
  567.    1------->         	}
  568.                      }
  569.                      if (mod.ischeme==4) {
  570.                          /* tes field */
  571.                      	ixo = mod.iePx-bnd.ntap;
  572.                      	ixe = mod.iePx;
  573.                      	izo = mod.ioPz;
  574.                      	ize = mod.iePz;
  575.  + 1-------<         	for (ix=ixo; ix<ixe; ix++) {
  576.    1 Vcr2--<             	for (iz=izo; iz<ize; iz++) {
  577.    1 Vcr2                        tes[ix*n1+iz] = tes[(ixo-1)*n1+iz];
  578.    1 Vcr2-->             	}
  579.    1------->         	}
  580.                      }
  581.              
  582.                  }
  583.              
  584.              	/* Top */
  585.                  if (bnd.top==4 || bnd.top==2) {
  586.                      
  587.                      /* Rox field */
  588.                      ixo = mod.ioXx;
  589.                      ixe = mod.ieXx;
  590.                      if (bnd.lef==4 || bnd.lef==2) ixo -= bnd.ntap;
  591.                      if (bnd.rig==4 || bnd.rig==2) ixe += bnd.ntap;
  592.                      izo = mod.ioXz-bnd.ntap;
  593.                      ize = mod.ioXz;
  594.                      
  595.  + 1-------<         for (ix=ixo; ix<ixe; ix++) {
  596.    1 Vr2---<             for (iz=izo; iz<ize; iz++) {
  597.    1 Vr2                     rox[ix*n1+iz] = rox[ix*n1+ize];
  598.    1 Vr2--->             }
  599.    1------->         }
  600.                      
  601.                      /* roz field */
  602.                      ixo = mod.ioZx;
  603.                      ixe = mod.ieZx;
  604.                      if (bnd.lef==4 || bnd.lef==2) ixo -= bnd.ntap;
  605.                      if (bnd.rig==4 || bnd.rig==2) ixe += bnd.ntap;
  606.                      izo = mod.ioZz-bnd.ntap;
  607.                      ize = mod.ioZz;
  608.  + 1-------<         for (ix=ixo; ix<ixe; ix++) {
  609.    1 Vr2---<             for (iz=izo; iz<ize; iz++) {
  610.    1 Vr2                     roz[ix*n1+iz] = roz[ix*n1+ize];
  611.    1 Vr2--->             }
  612.    1------->         }
  613.                      /* l2m field */
  614.                      ixo = mod.ioPx;
  615.                      ixe = mod.iePx;
  616.                      izo = mod.ioPz;
  617.                      ize = mod.ioPz+bnd.ntap;
  618.  + 1-------<         for (ix=ixo; ix<ixe; ix++) {
  619.    1 Vr2---<             for (iz=izo; iz<ize; iz++) {
  620.    1 Vr2                     l2m[ix*n1+iz] = l2m[ix*n1+ize];
  621.    1 Vr2--->             }
  622.    1------->         }
  623.                      
  624.                      if (mod.ischeme>2) { /* Elastic Scheme */
  625.                      	/* lam field */
  626.                      	ixo = mod.ioPx;
  627.                      	ixe = mod.iePx;
  628.                      	izo = mod.ioPz;
  629.                      	ize = mod.ioPz+bnd.ntap;
  630.  + 1-------<         	for (ix=ixo; ix<ixe; ix++) {
  631.    1 Vr2---<             	for (iz=izo; iz<ize; iz++) {
  632.    1 Vr2                     	lam[ix*n1+iz] = lam[ix*n1+ize];
  633.    1 Vr2--->             	}
  634.    1------->         	}
  635.                          /* muu field */
  636.                          ixo = mod.ioTx;
  637.                          ixe = mod.ieTx;
  638.                          izo = mod.ioTz;
  639.                          ize = mod.ioTz+bnd.ntap;
  640.  + 1-------<             for (ix=ixo; ix<ixe; ix++) {
  641.    1 Vr2---<                 for (iz=izo; iz<ize; iz++) {
  642.    1 Vr2                         muu[ix*n1+iz] = muu[ix*n1+ize];
  643.    1 Vr2--->                 }
  644.    1------->             }
  645.                      }
  646.                      if (mod.ischeme==2 || mod.ischeme==4) {
  647.                          /* tss and tep field */
  648.                      	ixo = mod.ioPx;
  649.                      	ixe = mod.iePx;
  650.                      	izo = mod.ioPz;
  651.                      	ize = mod.ioPz+bnd.ntap;
  652.  + 1-------<         	for (ix=ixo; ix<ixe; ix++) {
  653.  + 1 r4----<             	for (iz=izo; iz<ize; iz++) {
  654.    1 r4                      	tss[ix*n1+iz] = tss[ix*n1+ize];
  655.    1 r4                          tep[ix*n1+iz] = tep[ix*n1+ize];
  656.    1 r4---->             	}
  657.    1------->         	}
  658.                      }
  659.                      if (mod.ischeme==4) {
  660.                          /* tes field */
  661.                      	ixo = mod.ioPx;
  662.                      	ixe = mod.iePx;
  663.                      	izo = mod.ioPz;
  664.                      	ize = mod.ioPz+bnd.ntap;
  665.  + 1-------<         	for (ix=ixo; ix<ixe; ix++) {
  666.    1 Vr2---<             	for (iz=izo; iz<ize; iz++) {
  667.    1 Vr2                         tes[ix*n1+iz] = tes[ix*n1+ize];
  668.    1 Vr2--->             	}
  669.    1------->         	}
  670.                      }
  671.              
  672.                  }
  673.                  
  674.              	/* Bottom */
  675.                  if (bnd.bot==4 || bnd.bot==2) {
  676.                      
  677.                      /* Rox field */
  678.                      ixo = mod.ioXx;
  679.                      ixe = mod.ieXx;
  680.                      if (bnd.lef==4 || bnd.lef==2) ixo -= bnd.ntap;
  681.                      if (bnd.rig==4 || bnd.rig==2) ixe += bnd.ntap;
  682.                      izo = mod.ieXz;
  683.                      ize = mod.ieXz+bnd.ntap;
  684.  + 1-------<         for (ix=ixo; ix<ixe; ix++) {
  685.    1 Vr2---<             for (iz=izo; iz<ize; iz++) {
  686.    1 Vr2                     rox[ix*n1+iz] = rox[ix*n1+izo-1];
  687.    1 Vr2--->             }
  688.    1------->         }
  689.                      
  690.                      /* roz field */
  691.                      ixo = mod.ioZx;
  692.                      ixe = mod.ieZx;
  693.                      if (bnd.lef==4 || bnd.lef==2) ixo -= bnd.ntap;
  694.                      if (bnd.rig==4 || bnd.rig==2) ixe += bnd.ntap;
  695.                      izo = mod.ieZz;
  696.                      ize = mod.ieZz+bnd.ntap;
  697.  + 1-------<         for (ix=ixo; ix<ixe; ix++) {
  698.    1 Vr2---<             for (iz=izo; iz<ize; iz++) {
  699.    1 Vr2                     roz[ix*n1+iz] = roz[ix*n1+izo-1];
  700.    1 Vr2--->             }
  701.    1------->         }
  702.                      /* l2m field */
  703.                      ixo = mod.ioPx;
  704.                      ixe = mod.iePx;
  705.                      izo = mod.iePz-bnd.ntap;
  706.                      ize = mod.iePz;
  707.  + 1-------<         for (ix=ixo; ix<ixe; ix++) {
  708.    1 Vr2---<             for (iz=izo; iz<ize; iz++) {
  709.    1 Vr2                     l2m[ix*n1+iz] = l2m[ix*n1+izo-1];
  710.    1 Vr2--->             }
  711.    1------->         }
  712.                      
  713.                      if (mod.ischeme>2) { /* Elastic Scheme */
  714.                      	/* lam field */
  715.                      	ixo = mod.ioPx;
  716.                      	ixe = mod.iePx;
  717.                      	izo = mod.iePz-bnd.ntap;
  718.                      	ize = mod.iePz;
  719.  + 1-------<         	for (ix=ixo; ix<ixe; ix++) {
  720.    1 Vr2---<             	for (iz=izo; iz<ize; iz++) {
  721.    1 Vr2                     	lam[ix*n1+iz] = lam[ix*n1+izo-1];
  722.    1 Vr2--->             	}
  723.    1------->         	}
  724.              
  725.                          /* muu */
  726.                          ixo = mod.ioTx;
  727.                          ixe = mod.ieTx;
  728.                          izo = mod.ieTz-bnd.ntap;
  729.                          ize = mod.ieTz;
  730.  + 1-------<             for (ix=ixo; ix<ixe; ix++) {
  731.    1 Vr2---<                 for (iz=izo; iz<ize; iz++) {
  732.    1 Vr2                         muu[ix*n1+iz] = muu[ix*n1+izo-1];
  733.    1 Vr2--->                 }
  734.    1------->             }
  735.                      }
  736.                      if (mod.ischeme==2 || mod.ischeme==4) {
  737.                          /* tss and tep field */
  738.                      	ixo = mod.ioPx;
  739.                      	ixe = mod.iePx;
  740.                      	izo = mod.iePz-bnd.ntap;
  741.                      	ize = mod.iePz;
  742.  + 1-------<         	for (ix=ixo; ix<ixe; ix++) {
  743.  + 1 r4----<             	for (iz=izo; iz<ize; iz++) {
  744.    1 r4                      	tss[ix*n1+iz] = tss[ix*n1+izo-1];
  745.    1 r4                          tep[ix*n1+iz] = tep[ix*n1+izo-1];
  746.    1 r4---->             	}
  747.    1------->         	}
  748.                      }
  749.                      if (mod.ischeme==4) {
  750.                          /* tes field */
  751.                      	ixo = mod.ioPx;
  752.                      	ixe = mod.iePx;
  753.                      	izo = mod.iePz-bnd.ntap;
  754.                      	ize = mod.iePz;
  755.  + 1-------<         	for (ix=ixo; ix<ixe; ix++) {
  756.    1 Vr2---<             	for (iz=izo; iz<ize; iz++) {
  757.    1 Vr2                         tes[ix*n1+iz] = tes[ix*n1+izo-1];
  758.    1 Vr2--->             	}
  759.    1------->         	}
  760.                      }
  761.              
  762.                  }
  763.               
  764.              /*
  765.                  writesufile("rox.su", rox, mod.naz, mod.nax, 0.0, 0.0, 1, 1);
  766.                  writesufile("roz.su", roz, mod.naz, mod.nax, 0.0, 0.0, 1, 1);
  767.                  writesufile("l2m.su", l2m, mod.naz, mod.nax, 0.0, 0.0, 1, 1);
  768.                  writesufile("lam.su", lam, mod.naz, mod.nax, 0.0, 0.0, 1, 1);
  769.                  writesufile("muu.su", muu, mod.naz, mod.nax, 0.0, 0.0, 1, 1);
  770.              */
  771.              /*
  772.                  for (ix=0; ix<mod.nax; ix++) {
  773.                      for (iz=0; iz<mod.naz; iz++) {
  774.                          rox[ix*n1+iz] = rox[10*n1+10];
  775.                          roz[ix*n1+iz] = roz[10*n1+10];
  776.                          l2m[ix*n1+iz] = l2m[10*n1+10];
  777.                          muu[ix*n1+iz] = muu[10*n1+10];
  778.                          lam[ix*n1+iz] = lam[10*n1+10];
  779.                      }
  780.                  }
  781.              */
  782.              
  783.              	free(cp);
  784.              	free(ro);
  785.                 	if (mod.ischeme>2) free(cs);
  786.              
  787.                  return 0;
  788.              }
  789.              
  790.              

CC-3021 CC: IPA File = readModel.c, Line = 77 
  "fopen" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 78 
  "__assert_fail" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 79 
  "fread" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 80 
  "__assert_fail" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 83 
  "fopen" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 84 
  "__assert_fail" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 85 
  "fread" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 86 
  "__assert_fail" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 90 
  "fopen" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 91 
  "__assert_fail" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 92 
  "fread" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 93 
  "__assert_fail" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 100 
  "fopen" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 101 
  "__assert_fail" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 102 
  "fread" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 103 
  "__assert_fail" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 107 
  "fopen" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 108 
  "__assert_fail" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 109 
  "fread" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 110 
  "__assert_fail" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-6287 CC: VECTOR File = readModel.c, Line = 118 
  A loop was not vectorized because it contains a call to function "fread" on line 119.

CC-3021 CC: IPA File = readModel.c, Line = 119 
  "fread" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 120 
  "__assert_fail" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 121 
  "fread" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 122 
  "__assert_fail" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 124 
  "fread" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 125 
  "__assert_fail" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 141 
  "fread" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 142 
  "__assert_fail" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-6308 CC: VECTOR File = readModel.c, Line = 143 
  A loop was not vectorized because the loop initialization would be too costly.

CC-6005 CC: SCALAR File = readModel.c, Line = 151 
  A loop was unrolled 2 times.

CC-6213 CC: VECTOR File = readModel.c, Line = 151 
  A loop was conditionally vectorized.

CC-3021 CC: IPA File = readModel.c, Line = 163 
  "fread" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 164 
  "__assert_fail" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-6005 CC: SCALAR File = readModel.c, Line = 165 
  A loop was unrolled 2 times.

CC-6213 CC: VECTOR File = readModel.c, Line = 165 
  A loop was conditionally vectorized.

CC-6005 CC: SCALAR File = readModel.c, Line = 171 
  A loop was unrolled 2 times.

CC-6213 CC: VECTOR File = readModel.c, Line = 171 
  A loop was conditionally vectorized.

CC-3021 CC: IPA File = readModel.c, Line = 178 
  "fread" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 180 
  "fread" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 183 
  "fread" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 187 
  "fread" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 191 
  "fread" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 196 
  "fclose" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 197 
  "fclose" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 198 
  "fclose" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 199 
  "fclose" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 200 
  "fclose" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-6287 CC: VECTOR File = readModel.c, Line = 204 
  A loop was not vectorized because it contains a call to function "vwarn" on line 206.

CC-3021 CC: IPA File = readModel.c, Line = 206 
  "vwarn" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = readModel.c, Line = 207 
  "verr" (called from "readModel") was not inlined because the compiler was unable to locate the routine.

CC-6291 CC: VECTOR File = readModel.c, Line = 217 
  A loop was not vectorized because a recurrence was found between "cp" at line 218 and "rox" at line 240.

CC-6291 CC: VECTOR File = readModel.c, Line = 248 
  A loop was not vectorized because a recurrence was found between "cp" at line 249 and "rox" at line 271.

CC-6291 CC: VECTOR File = readModel.c, Line = 292 
  A loop was not vectorized because a recurrence was found between "cp" at line 294 and "rox" at line 325.

CC-6291 CC: VECTOR File = readModel.c, Line = 293 
  A loop was not vectorized because a recurrence was found between "cp" at line 294 and "rox" at line 325.

CC-6005 CC: SCALAR File = readModel.c, Line = 345 
  A loop was unrolled 2 times.

CC-6291 CC: VECTOR File = readModel.c, Line = 345 
  A loop was not vectorized because a recurrence was found between "cp" at line 346 and "rox" at line 354.

CC-6308 CC: VECTOR File = readModel.c, Line = 360 
  A loop was not vectorized because the loop initialization would be too costly.

CC-6005 CC: SCALAR File = readModel.c, Line = 360 
  A loop was unrolled 2 times.

CC-6291 CC: VECTOR File = readModel.c, Line = 383 
  A loop was not vectorized because a recurrence was found between "cp" at line 385 and "rox" at line 393.

CC-6005 CC: SCALAR File = readModel.c, Line = 384 
  A loop was unrolled 2 times.

CC-6291 CC: VECTOR File = readModel.c, Line = 384 
  A loop was not vectorized because a recurrence was found between "cp" at line 385 and "rox" at line 393.

CC-6291 CC: VECTOR File = readModel.c, Line = 401 
  A loop was not vectorized because a recurrence was found between "rox" at line 404 and "roz" at line 405.

CC-6308 CC: VECTOR File = readModel.c, Line = 402 
  A loop was not vectorized because the loop initialization would be too costly.

CC-6005 CC: SCALAR File = readModel.c, Line = 402 
  A loop was unrolled 4 times.

CC-6294 CC: VECTOR File = readModel.c, Line = 422 
  A loop was not vectorized because a better candidate was found at line 423.

CC-6005 CC: SCALAR File = readModel.c, Line = 423 
  A loop was unrolled 2 times.

CC-6213 CC: VECTOR File = readModel.c, Line = 423 
  A loop was conditionally vectorized.

CC-6294 CC: VECTOR File = readModel.c, Line = 433 
  A loop was not vectorized because a better candidate was found at line 434.

CC-6005 CC: SCALAR File = readModel.c, Line = 434 
  A loop was unrolled 2 times.

CC-6213 CC: VECTOR File = readModel.c, Line = 434 
  A loop was conditionally vectorized.

CC-6294 CC: VECTOR File = readModel.c, Line = 443 
  A loop was not vectorized because a better candidate was found at line 444.

CC-6005 CC: SCALAR File = readModel.c, Line = 444 
  A loop was unrolled 2 times.

CC-6213 CC: VECTOR File = readModel.c, Line = 444 
  A loop was conditionally vectorized.

CC-6294 CC: VECTOR File = readModel.c, Line = 455 
  A loop was not vectorized because a better candidate was found at line 456.

CC-6005 CC: SCALAR File = readModel.c, Line = 456 
  A loop was unrolled 2 times.

CC-6213 CC: VECTOR File = readModel.c, Line = 456 
  A loop was conditionally vectorized.

CC-6294 CC: VECTOR File = readModel.c, Line = 465 
  A loop was not vectorized because a better candidate was found at line 466.

CC-6005 CC: SCALAR File = readModel.c, Line = 466 
  A loop was unrolled 2 times.

CC-6213 CC: VECTOR File = readModel.c, Line = 466 
  A loop was conditionally vectorized.

CC-6291 CC: VECTOR File = readModel.c, Line = 477 
  A loop was not vectorized because a recurrence was found between "tss" at line 479 and "tep" at line 480.

CC-6308 CC: VECTOR File = readModel.c, Line = 478 
  A loop was not vectorized because the loop initialization would be too costly.

CC-6005 CC: SCALAR File = readModel.c, Line = 478 
  A loop was unrolled 4 times.

CC-6294 CC: VECTOR File = readModel.c, Line = 490 
  A loop was not vectorized because a better candidate was found at line 491.

CC-6005 CC: SCALAR File = readModel.c, Line = 491 
  A loop was unrolled 2 times.

CC-6213 CC: VECTOR File = readModel.c, Line = 491 
  A loop was conditionally vectorized.

CC-6294 CC: VECTOR File = readModel.c, Line = 507 
  A loop was not vectorized because a better candidate was found at line 508.

CC-6005 CC: SCALAR File = readModel.c, Line = 508 
  A loop was unrolled 2 times.

CC-6213 CC: VECTOR File = readModel.c, Line = 508 
  A loop was conditionally vectorized.

CC-6294 CC: VECTOR File = readModel.c, Line = 518 
  A loop was not vectorized because a better candidate was found at line 519.

CC-6005 CC: SCALAR File = readModel.c, Line = 519 
  A loop was unrolled 2 times.

CC-6213 CC: VECTOR File = readModel.c, Line = 519 
  A loop was conditionally vectorized.

CC-6294 CC: VECTOR File = readModel.c, Line = 528 
  A loop was not vectorized because a better candidate was found at line 529.

CC-6005 CC: SCALAR File = readModel.c, Line = 529 
  A loop was unrolled 2 times.

CC-6213 CC: VECTOR File = readModel.c, Line = 529 
  A loop was conditionally vectorized.

CC-6294 CC: VECTOR File = readModel.c, Line = 540 
  A loop was not vectorized because a better candidate was found at line 541.

CC-6005 CC: SCALAR File = readModel.c, Line = 541 
  A loop was unrolled 2 times.

CC-6213 CC: VECTOR File = readModel.c, Line = 541 
  A loop was conditionally vectorized.

CC-6294 CC: VECTOR File = readModel.c, Line = 550 
  A loop was not vectorized because a better candidate was found at line 551.

CC-6005 CC: SCALAR File = readModel.c, Line = 551 
  A loop was unrolled 2 times.

CC-6213 CC: VECTOR File = readModel.c, Line = 551 
  A loop was conditionally vectorized.

CC-6291 CC: VECTOR File = readModel.c, Line = 562 
  A loop was not vectorized because a recurrence was found between "tss" at line 564 and "tep" at line 565.

CC-6308 CC: VECTOR File = readModel.c, Line = 563 
  A loop was not vectorized because the loop initialization would be too costly.

CC-6005 CC: SCALAR File = readModel.c, Line = 563 
  A loop was unrolled 4 times.

CC-6294 CC: VECTOR File = readModel.c, Line = 575 
  A loop was not vectorized because a better candidate was found at line 576.

CC-6005 CC: SCALAR File = readModel.c, Line = 576 
  A loop was unrolled 2 times.

CC-6213 CC: VECTOR File = readModel.c, Line = 576 
  A loop was conditionally vectorized.

CC-6294 CC: VECTOR File = readModel.c, Line = 595 
  A loop was not vectorized because a better candidate was found at line 596.

CC-6005 CC: SCALAR File = readModel.c, Line = 596 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = readModel.c, Line = 596 
  A loop was vectorized.

CC-6294 CC: VECTOR File = readModel.c, Line = 608 
  A loop was not vectorized because a better candidate was found at line 609.

CC-6005 CC: SCALAR File = readModel.c, Line = 609 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = readModel.c, Line = 609 
  A loop was vectorized.

CC-6294 CC: VECTOR File = readModel.c, Line = 618 
  A loop was not vectorized because a better candidate was found at line 619.

CC-6005 CC: SCALAR File = readModel.c, Line = 619 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = readModel.c, Line = 619 
  A loop was vectorized.

CC-6294 CC: VECTOR File = readModel.c, Line = 630 
  A loop was not vectorized because a better candidate was found at line 631.

CC-6005 CC: SCALAR File = readModel.c, Line = 631 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = readModel.c, Line = 631 
  A loop was vectorized.

CC-6294 CC: VECTOR File = readModel.c, Line = 640 
  A loop was not vectorized because a better candidate was found at line 641.

CC-6005 CC: SCALAR File = readModel.c, Line = 641 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = readModel.c, Line = 641 
  A loop was vectorized.

CC-6291 CC: VECTOR File = readModel.c, Line = 652 
  A loop was not vectorized because a recurrence was found between "tss" at line 654 and "tep" at line 655.

CC-6005 CC: SCALAR File = readModel.c, Line = 653 
  A loop was unrolled 4 times.

CC-6291 CC: VECTOR File = readModel.c, Line = 653 
  A loop was not vectorized because a recurrence was found between "tss" at line 654 and "tep" at line 655.

CC-6294 CC: VECTOR File = readModel.c, Line = 665 
  A loop was not vectorized because a better candidate was found at line 666.

CC-6005 CC: SCALAR File = readModel.c, Line = 666 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = readModel.c, Line = 666 
  A loop was vectorized.

CC-6254 CC: VECTOR File = readModel.c, Line = 684 
  A loop was not vectorized because a recurrence was found on "rox" at line 686.

CC-6005 CC: SCALAR File = readModel.c, Line = 685 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = readModel.c, Line = 685 
  A loop was vectorized.

CC-6254 CC: VECTOR File = readModel.c, Line = 697 
  A loop was not vectorized because a recurrence was found on "roz" at line 699.

CC-6005 CC: SCALAR File = readModel.c, Line = 698 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = readModel.c, Line = 698 
  A loop was vectorized.

CC-6254 CC: VECTOR File = readModel.c, Line = 707 
  A loop was not vectorized because a recurrence was found on "l2m" at line 709.

CC-6005 CC: SCALAR File = readModel.c, Line = 708 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = readModel.c, Line = 708 
  A loop was vectorized.

CC-6254 CC: VECTOR File = readModel.c, Line = 719 
  A loop was not vectorized because a recurrence was found on "lam" at line 721.

CC-6005 CC: SCALAR File = readModel.c, Line = 720 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = readModel.c, Line = 720 
  A loop was vectorized.

CC-6254 CC: VECTOR File = readModel.c, Line = 730 
  A loop was not vectorized because a recurrence was found on "muu" at line 732.

CC-6005 CC: SCALAR File = readModel.c, Line = 731 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = readModel.c, Line = 731 
  A loop was vectorized.

CC-6291 CC: VECTOR File = readModel.c, Line = 742 
  A loop was not vectorized because a recurrence was found between "tss" at line 744 and "tep" at line 745.

CC-6005 CC: SCALAR File = readModel.c, Line = 743 
  A loop was unrolled 4 times.

CC-6291 CC: VECTOR File = readModel.c, Line = 743 
  A loop was not vectorized because a recurrence was found between "tss" at line 744 and "tep" at line 745.

CC-6254 CC: VECTOR File = readModel.c, Line = 755 
  A loop was not vectorized because a recurrence was found on "tes" at line 757.

CC-6005 CC: SCALAR File = readModel.c, Line = 756 
  A loop was unrolled 2 times.

CC-6204 CC: VECTOR File = readModel.c, Line = 756 
  A loop was vectorized.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
